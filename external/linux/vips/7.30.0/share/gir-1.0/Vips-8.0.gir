<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <namespace name="Vips"
             version="8.0"
             shared-library="libvips.so.32"
             c:identifier-prefixes="Vips,vips"
             c:symbol-prefixes="vips,im,im_">
    <alias name="ArgumentTable" c:type="VipsArgumentTable">
      <type name="GLib.HashTable" c:type="GHashTable"/>
    </alias>
    <alias name="ArrayDouble" c:type="VipsArrayDouble">
      <type name="Area" c:type="VipsArea"/>
    </alias>
    <alias name="Pel" c:type="VipsPel">
      <doc xml:whitespace="preserve">A picture element. Cast this to whatever the associated VipsBandFormat says
to get the value.</doc>
      <type name="guint8" c:type="unsigned char"/>
    </alias>
    <constant name="ARGUMENT_OPTIONAL_INPUT"
              value="0"
              c:type="VIPS_ARGUMENT_OPTIONAL_INPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_OPTIONAL_OUTPUT"
              value="0"
              c:type="VIPS_ARGUMENT_OPTIONAL_OUTPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_INPUT"
              value="0"
              c:type="VIPS_ARGUMENT_REQUIRED_INPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ARGUMENT_REQUIRED_OUTPUT"
              value="0"
              c:type="VIPS_ARGUMENT_REQUIRED_OUTPUT">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="Align"
                 glib:type-name="VipsAlign"
                 glib:get-type="vips_align_get_type"
                 c:type="VipsAlign">
      <doc xml:whitespace="preserve">See vips_join() and so on.

Operations like vips_join() need to be told whether to align images on the
low or high coordinate edge, or centre.

See also: vips_join().</doc>
      <member name="low"
              value="0"
              c:identifier="VIPS_ALIGN_LOW"
              glib:nick="low"/>
      <member name="centre"
              value="1"
              c:identifier="VIPS_ALIGN_CENTRE"
              glib:nick="centre"/>
      <member name="high"
              value="2"
              c:identifier="VIPS_ALIGN_HIGH"
              glib:nick="high"/>
      <member name="last"
              value="3"
              c:identifier="VIPS_ALIGN_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="Angle"
                 glib:type-name="VipsAngle"
                 glib:get-type="vips_angle_get_type"
                 c:type="VipsAngle">
      <doc xml:whitespace="preserve">See vips_rot() and so on.

Fixed rotate angles.

See also: vips_rot().</doc>
      <member name="0" value="0" c:identifier="VIPS_ANGLE_0" glib:nick="0"/>
      <member name="90" value="1" c:identifier="VIPS_ANGLE_90" glib:nick="90"/>
      <member name="180"
              value="2"
              c:identifier="VIPS_ANGLE_180"
              glib:nick="180"/>
      <member name="270"
              value="3"
              c:identifier="VIPS_ANGLE_270"
              glib:nick="270"/>
      <member name="last"
              value="4"
              c:identifier="VIPS_ANGLE_LAST"
              glib:nick="last"/>
    </enumeration>
    <glib:boxed glib:name="Area"
                c:symbol-prefix="area"
                glib:type-name="VipsArea"
                glib:get-type="vips_area_get_type">
      <constructor name="new" c:identifier="vips_area_new">
        <doc xml:whitespace="preserve">An area of memory with a free function. (eg. \0-terminated string, or a 
struct). Inital count == 1, so _unref() after attaching somewhere.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data will be freed with this function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array" c:identifier="vips_area_new_array">
        <doc xml:whitespace="preserve">An area which holds an array of elements of some GType. To set values for
the elements, get the pointer and write.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">%GType of elements to store</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="sizeof_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">sizeof() an element in the array</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_array_object"
                   c:identifier="vips_area_new_array_object">
        <doc xml:whitespace="preserve">An area which holds an array of GObjects. See vips_area_new_array(). When
the area is freed, each %GObject will be unreffed.

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of elements in the array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_blob" c:identifier="vips_area_new_blob">
        <doc xml:whitespace="preserve">Like vips_area_new(), but track a length as well.

An area of mem with a free func and a length (some sort of binary object,
like an ICC profile).

See also: vips_area_unref().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsArea.</doc>
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
        <parameters>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">@data will be freed with this function</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data will be freed with this function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes in @data</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="vips_area_copy">
        <return-value transfer-ownership="full">
          <type name="Area" c:type="VipsArea*"/>
        </return-value>
      </method>
      <method name="get_data" c:identifier="vips_area_get_data">
        <doc xml:whitespace="preserve">Return the data pointer plus optionally the length in bytes of an area, 
the number of elements, the %GType of each element and the sizeof() each
element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The pointer held by @area.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optionally return length in bytes here</doc>
            <type name="gulong" c:type="size_t*"/>
          </parameter>
          <parameter name="n" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optionally return number of elements here</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optionally return element type here</doc>
            <type name="GType" c:type="GType*"/>
          </parameter>
          <parameter name="sizeof_type"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optionally return sizeof() element type here</doc>
            <type name="gulong" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="vips_area_unref">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </glib:boxed>
    <callback name="ArgumentClassMapFn"
              c:type="VipsArgumentClassMapFn"
              introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="ArgumentFlags"
              glib:type-name="VipsArgumentFlags"
              glib:get-type="vips_argument_flags_get_type"
              c:type="VipsArgumentFlags">
      <doc xml:whitespace="preserve">Flags we associate with each object argument.

Have separate input &amp; output flags. Both set is an error; neither set is OK.

Input gobjects are automatically reffed, output gobjects automatically ref
us. We also automatically watch for "destroy" and unlink.

@VIPS_ARGUMENT_SET_ALWAYS is handy for arguments which are set from C. For
example, VipsImage::width is a property that gives access to the Xsize
member of struct _VipsImage. We default its 'assigned' to TRUE
since the field is always set directly by C.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_ARGUMENT_NONE"
              glib:nick="none"/>
      <member name="required"
              value="1"
              c:identifier="VIPS_ARGUMENT_REQUIRED"
              glib:nick="required"/>
      <member name="construct"
              value="2"
              c:identifier="VIPS_ARGUMENT_CONSTRUCT"
              glib:nick="construct"/>
      <member name="set_once"
              value="4"
              c:identifier="VIPS_ARGUMENT_SET_ONCE"
              glib:nick="set-once"/>
      <member name="set_always"
              value="8"
              c:identifier="VIPS_ARGUMENT_SET_ALWAYS"
              glib:nick="set-always"/>
      <member name="input"
              value="16"
              c:identifier="VIPS_ARGUMENT_INPUT"
              glib:nick="input"/>
      <member name="output"
              value="32"
              c:identifier="VIPS_ARGUMENT_OUTPUT"
              glib:nick="output"/>
    </bitfield>
    <callback name="ArgumentMapFn"
              c:type="VipsArgumentMapFn"
              introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type c:type="VipsArgumentInstance*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="ArrayImage"
                c:symbol-prefix="array_image"
                glib:type-name="VipsArrayImage"
                glib:get-type="vips_array_image_get_type">
    </glib:boxed>
    <enumeration name="BandFormat"
                 glib:type-name="VipsBandFormat"
                 glib:get-type="vips_band_format_get_type"
                 c:type="VipsBandFormat">
      <doc xml:whitespace="preserve">The format used for each band element. 

Each corresponnds to a native C type for the current machine. For example,
#VIPS_FORMAT_USHORT is &lt;type&gt;unsigned short&lt;/type&gt;.</doc>
      <member name="notset"
              value="-1"
              c:identifier="VIPS_FORMAT_NOTSET"
              glib:nick="notset"/>
      <member name="uchar"
              value="0"
              c:identifier="VIPS_FORMAT_UCHAR"
              glib:nick="uchar"/>
      <member name="char"
              value="1"
              c:identifier="VIPS_FORMAT_CHAR"
              glib:nick="char"/>
      <member name="ushort"
              value="2"
              c:identifier="VIPS_FORMAT_USHORT"
              glib:nick="ushort"/>
      <member name="short"
              value="3"
              c:identifier="VIPS_FORMAT_SHORT"
              glib:nick="short"/>
      <member name="uint"
              value="4"
              c:identifier="VIPS_FORMAT_UINT"
              glib:nick="uint"/>
      <member name="int"
              value="5"
              c:identifier="VIPS_FORMAT_INT"
              glib:nick="int"/>
      <member name="float"
              value="6"
              c:identifier="VIPS_FORMAT_FLOAT"
              glib:nick="float"/>
      <member name="complex"
              value="7"
              c:identifier="VIPS_FORMAT_COMPLEX"
              glib:nick="complex"/>
      <member name="double"
              value="8"
              c:identifier="VIPS_FORMAT_DOUBLE"
              glib:nick="double"/>
      <member name="dpcomplex"
              value="9"
              c:identifier="VIPS_FORMAT_DPCOMPLEX"
              glib:nick="dpcomplex"/>
      <member name="last"
              value="10"
              c:identifier="VIPS_FORMAT_LAST"
              glib:nick="last"/>
      <function name="iscomplex" c:identifier="vips_band_format_iscomplex">
        <doc xml:whitespace="preserve">Return %TRUE if @fmt is one of the complex types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isfloat" c:identifier="vips_band_format_isfloat">
        <doc xml:whitespace="preserve">Return %TRUE if @format is one of the float types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isint" c:identifier="vips_band_format_isint">
        <doc xml:whitespace="preserve">Return %TRUE if @format is one of the integer types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="isuint" c:identifier="vips_band_format_isuint">
        <doc xml:whitespace="preserve">Return %TRUE if @format is one of the unsigned integer types.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format to test</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <glib:boxed glib:name="Blob"
                c:symbol-prefix="blob"
                glib:type-name="VipsBlob"
                glib:get-type="vips_blob_get_type">
    </glib:boxed>
    <enumeration name="CacheStrategy"
                 glib:type-name="VipsCacheStrategy"
                 glib:get-type="vips_cache_strategy_get_type"
                 c:type="VipsCacheStrategy">
      <doc xml:whitespace="preserve">See vips_tilecache() and friends.

Used to hint to caches about the expected access pattern. RANDOM might mean
LRU eviction, SEQUENTIAL might mean top-most eviction.

See also: vips_tilecache().</doc>
      <member name="random"
              value="0"
              c:identifier="VIPS_CACHE_RANDOM"
              glib:nick="random"/>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_CACHE_SEQUENTIAL"
              glib:nick="sequential"/>
      <member name="last"
              value="2"
              c:identifier="VIPS_CACHE_LAST"
              glib:nick="last"/>
    </enumeration>
    <callback name="CallbackFn" c:type="VipsCallbackFn">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClassMapFn" c:type="VipsClassMapFn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Coding"
                 glib:type-name="VipsCoding"
                 glib:get-type="vips_coding_get_type"
                 c:type="VipsCoding">
      <doc xml:whitespace="preserve">How pixels are coded. 

Normally, pixels are uncoded and can be manipulated as you would expect.
However some file formats code pixels for compression, and sometimes it's
useful to be able to manipulate images in the coded format.

The gaps in the numbering are historical and must be maintained. Allocate 
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_CODING_ERROR"
              glib:nick="error"/>
      <member name="none"
              value="0"
              c:identifier="VIPS_CODING_NONE"
              glib:nick="none"/>
      <member name="labq"
              value="2"
              c:identifier="VIPS_CODING_LABQ"
              glib:nick="labq"/>
      <member name="rad"
              value="6"
              c:identifier="VIPS_CODING_RAD"
              glib:nick="rad"/>
      <member name="last"
              value="7"
              c:identifier="VIPS_CODING_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="DemandStyle"
                 glib:type-name="VipsDemandStyle"
                 glib:get-type="vips_demand_style_get_type"
                 c:type="VipsDemandStyle">
      <doc xml:whitespace="preserve">See vips_demand_hint(). Operations can hint to the VIPS image IO system about
the kind of demand geometry they prefer. 

These demand styles are given below in order of increasing
restrictiveness.  When demanding output from a pipeline, 
vips_image_generate()
will use the most restrictive of the styles requested by the operations 
in the pipeline.

#VIPS_DEMAND_STYLE_THINSTRIP --- This operation would like to output strips 
the width of the image and a few pels high. This is option suitable for 
point-to-point operations, such as those in the arithmetic package.

This option is only efficient for cases where each output pel depends 
upon the pel in the corresponding position in the input image.

#VIPS_DEMAND_STYLE_FATSTRIP --- This operation would like to output strips 
the width of the image and as high as possible. This option is suitable 
for area operations which do not violently transform coordinates, such 
as im_conv(). 

#VIPS_DEMAND_STYLE_SMALLTILE --- This is the most general demand format.
Output is demanded in small (around 100x100 pel) sections. This style works 
reasonably efficiently, even for bizzare operations like 45 degree rotate.

#VIPS_DEMAND_STYLE_ANY --- This image is not being demand-read from a disc 
file (even indirectly) so any demand style is OK. It's used for things like
im_black() where the pixels are calculated.

See also: vips_demand_hint().</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_DEMAND_STYLE_ERROR"
              glib:nick="error"/>
      <member name="smalltile"
              value="0"
              c:identifier="VIPS_DEMAND_STYLE_SMALLTILE"
              glib:nick="smalltile"/>
      <member name="fatstrip"
              value="1"
              c:identifier="VIPS_DEMAND_STYLE_FATSTRIP"
              glib:nick="fatstrip"/>
      <member name="thinstrip"
              value="2"
              c:identifier="VIPS_DEMAND_STYLE_THINSTRIP"
              glib:nick="thinstrip"/>
      <member name="any"
              value="3"
              c:identifier="VIPS_DEMAND_STYLE_ANY"
              glib:nick="any"/>
    </enumeration>
    <enumeration name="Direction"
                 glib:type-name="VipsDirection"
                 glib:get-type="vips_direction_get_type"
                 c:type="VipsDirection">
      <doc xml:whitespace="preserve">See vips_flip(), vips_join() and so on.

Operations like vips_flip() need to be told whether to flip left-right or
top-bottom. 

See also: vips_flip(), vips_join().</doc>
      <member name="horizontal"
              value="0"
              c:identifier="VIPS_DIRECTION_HORIZONTAL"
              glib:nick="horizontal"/>
      <member name="vertical"
              value="1"
              c:identifier="VIPS_DIRECTION_VERTICAL"
              glib:nick="vertical"/>
      <member name="last"
              value="2"
              c:identifier="VIPS_DIRECTION_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="Extend"
                 glib:type-name="VipsExtend"
                 glib:get-type="vips_extend_get_type"
                 c:type="VipsExtend">
      <doc xml:whitespace="preserve">See vips_embed(), vips_conv(), vips_affine() and so on.

When the edges of an image are extended, you can specify
how you want the extension done. 

#VIPS_EXTEND_BLACK --- new pixels are black, ie. all bits are zero. 

#VIPS_EXTEND_COPY --- each new pixel takes the value of the nearest edge
pixel

#VIPS_EXTEND_REPEAT --- the image is tiled to fill the new area

#VIPS_EXTEND_MIRROR --- the image is reflected and tiled to reduce hash
edges

#VIPS_EXTEND_WHITE --- new pixels are white, ie. all bits are set

We have to specify the exact value of each enum member since we have to 
keep these frozen for back compat with vips7.

See also: vips_embed().</doc>
      <member name="black"
              value="0"
              c:identifier="VIPS_EXTEND_BLACK"
              glib:nick="black"/>
      <member name="copy"
              value="1"
              c:identifier="VIPS_EXTEND_COPY"
              glib:nick="copy"/>
      <member name="repeat"
              value="2"
              c:identifier="VIPS_EXTEND_REPEAT"
              glib:nick="repeat"/>
      <member name="mirror"
              value="3"
              c:identifier="VIPS_EXTEND_MIRROR"
              glib:nick="mirror"/>
      <member name="white"
              value="4"
              c:identifier="VIPS_EXTEND_WHITE"
              glib:nick="white"/>
      <member name="last"
              value="5"
              c:identifier="VIPS_EXTEND_LAST"
              glib:nick="last"/>
    </enumeration>
    <class name="Foreign"
           c:symbol-prefix="foreign"
           parent="Operation"
           abstract="1"
           glib:type-name="VipsForeign"
           glib:get-type="vips_foreign_get_type">
      <function name="find_load" c:identifier="vips_foreign_find_load">
        <doc xml:whitespace="preserve">Searches for an operation you could use to load @filename. 

See also: vips_foreign_read().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of an operation on success, %NULL on error</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to find a loader for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_load_options"
                c:identifier="vips_foreign_find_load_options">
        <doc xml:whitespace="preserve">Searches for an operation you could use to load @filename. 

Arguments to the loader may be embedded in the filename using the usual
syntax.

See also: vips_foreign_load().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to find a loader for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save" c:identifier="vips_foreign_find_save">
        <doc xml:whitespace="preserve">Searches for an operation you could use to write to @filename.

@filename may not contain embedded options. See
vips_foreign_find_save_options() if your filename may have options in.

See also: vips_foreign_write().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of an operation on success, %NULL on error</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">name to find a saver for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="find_save_options"
                c:identifier="vips_foreign_find_save_options">
        <doc xml:whitespace="preserve">Searches for an operation you could use to write to @filename.

@filename may contain embedded options. See
vips_foreign_find_save() if your filename does not options in.

See also: vips_foreign_write().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">name to find a saver for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="is_a" c:identifier="vips_foreign_is_a">
        <doc xml:whitespace="preserve">Return %TRUE if @filename can be loaded by @loader. @loader is something
like "tiffload" or "VipsForeignLoadTiff".</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @filename can be loaded by @loader.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loader" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of loader to use for test</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to test</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_foreign_map" introspectable="0">
        <doc xml:whitespace="preserve">Apply a function to every #VipsForeignClass that VIPS knows about. Foreigns
are presented to the function in priority order. 

Like all VIPS map functions, if @fn returns %NULL, iteration continues. If
it returns non-%NULL, iteration terminates and that value is returned. The
map function returns %NULL if all calls return %NULL.

See also: vips_slist_map().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of iteration</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="base" transfer-ownership="none">
            <doc xml:whitespace="preserve">base class to search below (eg. "VipsForeignLoad")</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="fn" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">function to apply to each #VipsForeignClass</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <bitfield name="ForeignFlags"
              glib:type-name="VipsForeignFlags"
              glib:get-type="vips_foreign_flags_get_type"
              c:type="VipsForeignFlags">
      <doc xml:whitespace="preserve">Some hints about the image loader.

@VIPS_FOREIGN_PARTIAL means that the image can be read directly from the
file without needing to be unpacked to a temporary image first. 

@VIPS_FOREIGN_SEQUENTIAL means that the loader supports lazy reading, but
only top-to-bottom (sequential) access. Formats like PNG can read sets of
scanlines, for example, but only in order. 

If neither PARTIAL or SEQUENTIAL is set, the loader only supports whole
image read. Setting both PARTIAL and SEQUENTIAL is an error.

@VIPS_FOREIGN_BIGENDIAN means that image pixels are most-significant byte
first. Depending on the native byte order of the host machine, you may
need to swap bytes. See copy_swap().</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_NONE"
              glib:nick="none"/>
      <member name="partial"
              value="1"
              c:identifier="VIPS_FOREIGN_PARTIAL"
              glib:nick="partial"/>
      <member name="sequential"
              value="2"
              c:identifier="VIPS_FOREIGN_SEQUENTIAL"
              glib:nick="sequential"/>
      <member name="bigendian"
              value="4"
              c:identifier="VIPS_FOREIGN_BIGENDIAN"
              glib:nick="bigendian"/>
      <member name="all"
              value="7"
              c:identifier="VIPS_FOREIGN_ALL"
              glib:nick="all"/>
    </bitfield>
    <class name="ForeignLoad"
           c:symbol-prefix="foreign_load"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignLoad"
           glib:get-type="vips_foreign_load_get_type">
      <doc xml:whitespace="preserve">@header() must set at least the header fields of @out. @laod(), if defined,
must load the pixels to @real.</doc>
      <function name="options"
                c:identifier="vips_foreign_load_options"
                introspectable="0">
        <doc xml:whitespace="preserve">Loads @filename into @out using the loader recommended by
vips_foreign_find_load().

Arguments to the loader may be embedded in the filename using the usual
syntax. They may also be given as a set of NULL-terminated optional
arguments.

See also: vips_foreign_load().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to load</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">output image</doc>
            <type name="Image" c:type="VipsImage**"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <property name="disc" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none">
        <type name="ForeignFlags"/>
      </property>
      <property name="out" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
      <property name="sequential" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
    </class>
    <class name="ForeignSave"
           c:symbol-prefix="foreign_save"
           parent="Foreign"
           abstract="1"
           glib:type-name="VipsForeignSave"
           glib:get-type="vips_foreign_save_get_type">
      <function name="options"
                c:identifier="vips_foreign_save_options"
                introspectable="0">
        <doc xml:whitespace="preserve">Saves @in to @filename using the saver recommended by
vips_foreign_find_save(). 

Arguments to the saver may be embedded in the filename using the usual
syntax. They may also be given as a set of NULL-terminated optional
arguments.

See also: vips_foreign_save().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <doc xml:whitespace="preserve">image to write</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to write to</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <property name="in" writable="1" transfer-ownership="none">
        <type name="Image"/>
      </property>
    </class>
    <enumeration name="ForeignTiffCompression"
                 glib:type-name="VipsForeignTiffCompression"
                 glib:get-type="vips_foreign_tiff_compression_get_type"
                 c:type="VipsForeignTiffCompression">
      <doc xml:whitespace="preserve">The compression types supported by the tiff writer.

Use @Q to set the jpeg compression level, default 75.

Use @prediction to set the lzw or deflate prediction, default none.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_NONE"
              glib:nick="none"/>
      <member name="jpeg"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_JPEG"
              glib:nick="jpeg"/>
      <member name="deflate"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE"
              glib:nick="deflate"/>
      <member name="packbits"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS"
              glib:nick="packbits"/>
      <member name="ccittfax4"
              value="4"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4"
              glib:nick="ccittfax4"/>
      <member name="lzw"
              value="5"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_LZW"
              glib:nick="lzw"/>
      <member name="last"
              value="6"
              c:identifier="VIPS_FOREIGN_TIFF_COMPRESSION_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="ForeignTiffPredictor"
                 glib:type-name="VipsForeignTiffPredictor"
                 glib:get-type="vips_foreign_tiff_predictor_get_type"
                 c:type="VipsForeignTiffPredictor">
      <doc xml:whitespace="preserve">The predictor can help deflate and lzw compression. The values are fixed by
the tiff library.</doc>
      <member name="none"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_NONE"
              glib:nick="none"/>
      <member name="horizontal"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL"
              glib:nick="horizontal"/>
      <member name="float"
              value="3"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT"
              glib:nick="float"/>
      <member name="last"
              value="4"
              c:identifier="VIPS_FOREIGN_TIFF_PREDICTOR_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="ForeignTiffResunit"
                 glib:type-name="VipsForeignTiffResunit"
                 glib:get-type="vips_foreign_tiff_resunit_get_type"
                 c:type="VipsForeignTiffResunit">
      <doc xml:whitespace="preserve">Use inches or centimeters as the resolution unit for a tiff file.</doc>
      <member name="cm"
              value="0"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_CM"
              glib:nick="cm"/>
      <member name="inch"
              value="1"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_INCH"
              glib:nick="inch"/>
      <member name="last"
              value="2"
              c:identifier="VIPS_FOREIGN_TIFF_RESUNIT_LAST"
              glib:nick="last"/>
    </enumeration>
    <constant name="INTERPOLATE_SCALE"
              value="1"
              c:type="VIPS_INTERPOLATE_SCALE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="INTERPOLATE_SHIFT"
              value="12"
              c:type="VIPS_INTERPOLATE_SHIFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Image"
           c:symbol-prefix="image"
           parent="Object"
           glib:type-name="VipsImage"
           glib:get-type="vips_image_get_type">
      <doc xml:whitespace="preserve">An image. These can represent an image on disc, a memory buffer, an image
in the process of being written to disc or a partially evaluated image
in memory.</doc>
      <constructor name="new" c:identifier="vips_image_new">
        <doc xml:whitespace="preserve">vips_image_new() creates a "glue" descriptor you can use to join two image 
processing operations together. 

It is the equivalent of vips_image_new_mode("xxx", "p").</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_array" c:identifier="vips_image_new_array">
        <doc xml:whitespace="preserve">This convenience function makes an image which is an array: a one-band
VIPS_FORMAT_DOUBLE image held in memory.

Use VIPS_IMAGE_ADDR() to address pixels in the image.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_buffer" c:identifier="vips_image_new_buffer">
        <doc xml:whitespace="preserve">vips_image_new_buffer() creates a new VipsImage which when written to will
create a memory buffer. It is a convenience function for
vips_image_new_mode(vips_image_temp_name(), "t").

See also: vips_image_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
      </constructor>
      <constructor name="new_disc_temp"
                   c:identifier="vips_image_new_disc_temp">
        <doc xml:whitespace="preserve">Make a "w" disc #VipsImage which will be automatically unlinked when it is
destroyed. @format is something like "%s.v" for a vips file.

The file is created in the temporary directory, see vips__temp_name().

See also: vips__temp_name().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format of file</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="vips_image_new_from_file">
        <doc xml:whitespace="preserve">vips_image_new_from_file() opens @filename for reading in mode "r". See
vips_image_new_mode() for details.

See also: vips_image_new_mode().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to open</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file_raw"
                   c:identifier="vips_image_new_from_file_raw">
        <doc xml:whitespace="preserve">This function maps the named file and returns a #VipsImage you can use to
read it.

It returns an 8-bit image with @bands bands. If the image is not 8-bit, use 
im_copy_set() to transform the descriptor after loading it.

See also: im_copy_set(), im_raw2vips(), vips_image_new_from_file().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">filename to open</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:whitespace="preserve">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">bytes to skip at start of file</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_memory"
                   c:identifier="vips_image_new_from_memory">
        <doc xml:whitespace="preserve">This function wraps an #IMAGE around a memory buffer. VIPS does not take
responsibility for the area of memory, it's up to you to make sure it's
freed when the image is closed. See for example #VipsObject::close.

See also: im_binfile(), im_raw2vips(), vips_image_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">start of memory area</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:whitespace="preserve">image bands (or bytes per pixel)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bandfmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">image format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_mode" c:identifier="vips_image_new_mode">
        <doc xml:whitespace="preserve">vips_image_new_mode() examines the mode string and creates an 
appropriate #VipsImage.

&lt;itemizedlist&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"t"&lt;/emphasis&gt;
creates a temporary memory buffer image.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"p"&lt;/emphasis&gt;
creates a "glue" descriptor you can use to join operations, see also
vips_image_new().
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"r"&lt;/emphasis&gt;
opens the named file for reading. If the file is not in the native 
VIPS format for your machine, vips_image_new_mode() 
automatically converts the file for you. 

Some formats (eg. tiled tiff) are read directly. 

Some formats (eg. strip tiff) do not support random access and can't
be processed directly. Small images are decompressed to memory and
loaded from there, large images are decompressed to a disc file and
processed from that.

If the operations you intend to perform are sequential, that is, they
operate in a strict top-to-bottom manner, you can use sequential mode
instead, see "rs" below,
or you can use the lower-level 
API and control the loading process yourself. See 
#VipsForeign. 

See im_system_image() for an explanation of how VIPS selects a
location for the temporary file.

The disc threshold can be set with the "--vips-disc-threshold"
command-line argument, or the IM_DISC_THRESHOLD environment variable.
The value is a simple integer, but can take a unit postfix of "k", 
"m" or "g" to indicate kilobytes, megabytes or gigabytes.

For example:

|[
vips --vips-disc-threshold 500m copy fred.tif fred.v
]|

will copy via disc if "fred.tif" is more than 500 Mbytes
uncompressed. The default threshold is 100 MB.

Note that &lt;emphasis&gt;"r"&lt;/emphasis&gt; mode works in at least two stages. 
It should return quickly and let you check header fields. It will
only actually read in pixels when you first access them. 
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"rs"&lt;/emphasis&gt;
opens the named file for reading sequentially. It reads the source
image top-to-bottom and serves up pixels to the pipeline as required.
Provided the operations that connect to the image all demand pixels
only top-to-bottom as well, everything is fine and you avoid the
separate decompress stage.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"w"&lt;/emphasis&gt;
opens the named file for writing. It looks at the file name 
suffix to determine the type to write -- for example:

|[
vips_image_new_mode( "fred.tif", "w" )
]|

will write in TIFF format.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;
&lt;emphasis&gt;"rw"&lt;/emphasis&gt;
opens the named file for reading and writing. This will only work for 
VIPS files in a format native to your machine. It is only for 
paintbox-type applications.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #VipsImage, or %NULL on error.</doc>
          <type name="Image" c:type="VipsImage*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">file to open</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">mode to open with</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy_fields" c:identifier="vips_image_copy_fields">
        <doc xml:whitespace="preserve">Copy fields from @in to @out. A convenience
function over vips_image_copy_fields_array(). 

See also: vips_image_copy_fields_array(), vips_image_copy_fieldsv().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <doc xml:whitespace="preserve">image to copy from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_fields_array"
              c:identifier="vips_image_copy_fields_array">
        <doc xml:whitespace="preserve">Copy fields from all the input images to the output image. There must be at
least one input image. 

The first input image is used to set the main fields of @out (@width,
@coding and so on). 

Metadata from all the images is merged on to @out, with lower-numbered items 
overriding higher. So for example, if @in[0] and @in[1] both have an item
called "icc-profile", it's the profile attached to @in[0] that will end up
on @out.

Image history is completely copied from all @in. @out will have the history
of all the intput images.

See also: vips_image_copy_fieldsv(), vips_image_copy_fields().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <doc xml:whitespace="preserve">%NULL-terminated array of images to copy from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_fieldsv"
              c:identifier="vips_image_copy_fieldsv"
              introspectable="0">
        <doc xml:whitespace="preserve">Copy fields from all the input images to the output image. A convenience
function over vips_image_copy_fields_array(). 

See also: vips_image_copy_fields_array(), vips_image_copy_fields().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="in1" transfer-ownership="none">
            <doc xml:whitespace="preserve">first image to copy from</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="eval" c:identifier="vips_image_eval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="processed" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="vips_image_get">
        <doc xml:whitespace="preserve">Fill @value_copy with a copy of the header field. @value_copy must be zeroed 
but uninitialised.

This will return -1 and add a message to the error buffer if the field
does not exist. Use vips_image_get_typeof() to test for the 
existence
of a field first if you are not certain it will be there.

For example, to read a double from an image (though of course you would use
vips_image_get_double() in practice):

|[
GValue value = { 0 };
double d;

if( vips_image_get( image, field, &amp;value ) )
return( -1 );

if( G_VALUE_TYPE( &amp;value ) != G_TYPE_DOUBLE ) {
vips_error( "mydomain", 
_( "field \"%s\" is of type %s, not double" ),
field, 
g_type_name( G_VALUE_TYPE( &amp;value ) ) );
g_value_unset( &amp;value );
return( -1 );
}

d = g_value_get_double( &amp;value );
g_value_unset( &amp;value );

return( 0 );
]|

See also: vips_image_get_typeof(), vips_image_get_double().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to give the metadata</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value_copy" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GValue is copied into this</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_area" c:identifier="vips_image_get_area">
        <doc xml:whitespace="preserve">Gets @data from @image under the name @field. A convenience
function over vips_image_get(). Use vips_image_get_typeof() to test for
the existance of a piece of metadata.

See also: vips_image_set_area(), vips_image_get(),
vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">return metadata value</doc>
            <type name="gpointer" c:type="void**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_as_string" c:identifier="vips_image_get_as_string">
        <doc xml:whitespace="preserve">Gets @out from @im under the name @field. 
This function will read any field, returning it as a printable string.
You need to free the string with g_free() when you are done with it.

See also: vips_image_get(), vips_image_get_typeof().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">field name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">return field value as string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bands" c:identifier="vips_image_get_bands">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_blob"
              c:identifier="vips_image_get_blob"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets @blob from @image under the name @field, optionally return its length in
@length. A convenience
function over vips_image_get(). Use vips_image_get_typeof() to test for the 
existance
of a piece of metadata.

See also: vips_image_get(), vips_image_get_typeof(), vips_blob_get(),</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void**"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">return the blob length here, optionally</doc>
            <type name="gulong" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_coding" c:identifier="vips_image_get_coding">
        <return-value transfer-ownership="none">
          <type name="Coding" c:type="VipsCoding"/>
        </return-value>
      </method>
      <method name="get_data"
              c:identifier="vips_image_get_data"
              introspectable="0">
        <doc xml:whitespace="preserve">Return a pointer to the image's pixel data, if possible. This can involve
allocating large amounts of memory and performing a long computation. Image
pixels are laid out in band-packed rows.

See also: vips_image_wio_input().</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to pixel data, if possible.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
      </method>
      <method name="get_double" c:identifier="vips_image_get_double">
        <doc xml:whitespace="preserve">Gets @out from @im under the name @field. 
This function searches for
double-valued fields.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">field name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">return field value</doc>
            <type name="gdouble" c:type="double*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="vips_image_get_filename">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_format" c:identifier="vips_image_get_format">
        <return-value transfer-ownership="none">
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </return-value>
      </method>
      <method name="get_height" c:identifier="vips_image_get_height">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_history" c:identifier="vips_image_get_history">
        <doc xml:whitespace="preserve">This function reads the image history as a C string. The string is owned
by VIPS and must not be freed.

VIPS tracks the history of each image, that is, the sequence of operations
that generated that image. Applications built on VIPS need to call
vips_image_history_printf() for each action they perform, setting the 
command-line equivalent for the action.

See also: vips_image_history_printf().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The history of @image as a C string. Do not free!</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_int" c:identifier="vips_image_get_int">
        <doc xml:whitespace="preserve">Gets @out from @im under the name @field. This function searches for
int-valued fields.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">field name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">return field value</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interpretation"
              c:identifier="vips_image_get_interpretation">
        <return-value transfer-ownership="none">
          <type name="Interpretation" c:type="VipsInterpretation"/>
        </return-value>
      </method>
      <method name="get_kill" c:identifier="vips_image_get_kill">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_mode" c:identifier="vips_image_get_mode">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_string" c:identifier="vips_image_get_string">
        <doc xml:whitespace="preserve">Gets @out from @im under the name @field. 
This function searches for string-valued fields. 

Do not free @out.

See also: vips_image_get(), vips_image_get_typeof()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">field name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">return field value</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_typeof" c:identifier="vips_image_get_typeof">
        <doc xml:whitespace="preserve">Read the GType for a header field. Returns zero if there is no
field of that name. 

See also: vips_image_get().

field of that name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the GType of the field, or zero if there is no</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to search for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="vips_image_get_width">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_xoffset" c:identifier="vips_image_get_xoffset">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_xres" c:identifier="vips_image_get_xres">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </return-value>
      </method>
      <method name="get_yoffset" c:identifier="vips_image_get_yoffset">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_yres" c:identifier="vips_image_get_yres">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </return-value>
      </method>
      <method name="history_args" c:identifier="vips_image_history_args">
        <doc xml:whitespace="preserve">Formats the name/argv as a single string and calls
vips_image_history_printf(). A
convenience function for command-line prorams.

See also: vips_image_get_history().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">program name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of program arguments</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:whitespace="preserve">program arguments</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="history_printf"
              c:identifier="vips_image_history_printf"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a line to the image history. The @format and arguments are expanded, the
date and time is appended prefixed with a hash character, and the whole
string is appended to the image history and terminated with a newline.

For example:

|[
vips_image_history_printf( image, "vips im_invert %s %s", 
in-&gt;filename, out-&gt;filename );
]|

Might add the string

|[
"vips im_invert /home/john/fred.v /home/john/jim.v # Fri Apr  3 23:30:35
2009\n"
]|

VIPS operations don't add history lines for you because a single action at 
the application level might involve many VIPS operations. History must be
recorded by the application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">printf() format string</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="init_fields" c:identifier="vips_image_init_fields">
        <doc xml:whitespace="preserve">A convenience function to set the header fields after creating an image.
Normally you copy the fields from one of your input images with
vips_image_copy_fields() and then make
any adjustments you need, but if you are creating an image from scratch,
for example im_black() or im_jpeg2vips(), you do need to set all the
fields yourself.

See also: vips_image_copy_fields().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="xsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="ysize" transfer-ownership="none">
            <doc xml:whitespace="preserve">image height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="bands" transfer-ownership="none">
            <doc xml:whitespace="preserve">image bands</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">band format</doc>
            <type name="BandFormat" c:type="VipsBandFormat"/>
          </parameter>
          <parameter name="coding" transfer-ownership="none">
            <doc xml:whitespace="preserve">image coding</doc>
            <type name="Coding" c:type="VipsCoding"/>
          </parameter>
          <parameter name="interpretation" transfer-ownership="none">
            <doc xml:whitespace="preserve">image type</doc>
            <type name="Interpretation" c:type="VipsInterpretation"/>
          </parameter>
          <parameter name="xres" transfer-ownership="none">
            <doc xml:whitespace="preserve">horizontal resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="yres" transfer-ownership="none">
            <doc xml:whitespace="preserve">vertical resolution, pixels per millimetre</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="inplace" c:identifier="vips_image_inplace">
        <doc xml:whitespace="preserve">Gets @image ready for an in-place operation, such as im_insertplace().
After calling this function you can both read and write the image with 
VIPS_IMAGE_ADDR().

See also: im_insertplace(), vips_image_wio_input().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="invalidate_all" c:identifier="vips_image_invalidate_all">
        <doc xml:whitespace="preserve">Invalidate all pixel caches on an @image and any downstream images, that
is, images which depend on this image. 

The "invalidate" callback is triggered for all invalidated images.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="isMSBfirst" c:identifier="vips_image_isMSBfirst">
        <doc xml:whitespace="preserve">Return %TRUE if @image is in most-significant-
byte first form. This is the byte order used on the SPARC
architecture and others.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="isfile" c:identifier="vips_image_isfile">
        <doc xml:whitespace="preserve">Return %TRUE if @image represents a file on disc in some way.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="ispartial" c:identifier="vips_image_ispartial">
        <doc xml:whitespace="preserve">Return %TRUE if @im represents a partial image (a delayed calculation).</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="map" c:identifier="vips_image_map" introspectable="0">
        <doc xml:whitespace="preserve">This function calls @fn for every header field, including every item of 
metadata. 

Like all _map functions, the user function should return %NULL to continue
iteration, or a non-%NULL pointer to indicate early termination.

See also: vips_image_get_typeof(), vips_image_get().</doc>
        <return-value>
          <doc xml:whitespace="preserve">%NULL on success, the failing pointer otherwise.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="fn" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to call for each header field</doc>
            <type name="ImageMapFn" c:type="VipsImageMapFn"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for function</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="minimise_all" c:identifier="vips_image_minimise_all">
        <doc xml:whitespace="preserve">Minimise memory use on this image and any upstream images, that is, images
which this image depends upon. 

The "minimise" callback is triggered for all minimised images.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="pio_input" c:identifier="vips_image_pio_input">
        <doc xml:whitespace="preserve">Check that an image is readable with vips_region_prepare() and friends. 
If it isn't, try to transform the image so that vips_region_prepare() can 
work.

See also: vips_image_pio_output(), vips_region_prepare().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="posteval" c:identifier="vips_image_posteval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="preeval" c:identifier="vips_image_preeval">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="remove" c:identifier="vips_image_remove">
        <doc xml:whitespace="preserve">Find and remove an item of metadata. Return %FALSE if no metadata of that
name was found.

See also: vips_image_set(), vips_image_get_typeof().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if an item of metadata of that name was found and removed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to search for</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="vips_image_set">
        <doc xml:whitespace="preserve">Set a piece of metadata on @image. Any old metadata with that name is
destroyed. The GValue is copied into the image, so you need to unset the
value when you're done with it.

For example, to set an integer on an image (though you would use the
convenience function vips_image_set_int() in practice), you would need:

|[
GValue value = { 0 };

g_value_init( &amp;value, G_TYPE_INT );
g_value_set_int( &amp;value, 42 );
vips_image_set( image, field, &amp;value );
g_value_unset( &amp;value );

return( 0 );
]|

See also: vips_image_get().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to give the metadata</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GValue to copy into the image</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_area" c:identifier="vips_image_set_area">
        <doc xml:whitespace="preserve">Attaches @data as a metadata item on @image under the name @field. When
VIPS no longer needs the metadata, it will be freed with @free_fn.

See also: vips_image_get_double(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blob" c:identifier="vips_image_set_blob">
        <doc xml:whitespace="preserve">Attaches @blob as a metadata item on @image under the name @field. A 
convenience
function over vips_image_set() using an vips_blob.

See also: vips_image_get_blob(), vips_image_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="free_fn"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">free function for @data</doc>
            <type name="CallbackFn" c:type="VipsCallbackFn"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to area of memory</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">length of memory area</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delete_on_close"
              c:identifier="vips_image_set_delete_on_close">
        <doc xml:whitespace="preserve">Sets the delete_on_close flag for the image. If this flag is set, when
@image is finalized, the filename held in @image-&gt;filename at the time of
this call is unlinked.

This function is clearly extremely dangerous, use with great caution.

See also: vips__temp_name(), vips_image_new_disc_temp().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delete_on_close" transfer-ownership="none">
            <doc xml:whitespace="preserve">format of file</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="vips_image_set_double">
        <doc xml:whitespace="preserve">Attaches @d as a metadata item on @image under the name @field. A 
convenience
function over vips_image_set().

See also: vips_image_get_double(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="d" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata value</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="vips_image_set_int">
        <doc xml:whitespace="preserve">Attaches @i as a metadata item on @image under the name @field. A 
convenience
function over vips_image_set().

See also: vips_image_get_int(), vips_image_set()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata value</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_kill" c:identifier="vips_image_set_kill">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="kill" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_progress" c:identifier="vips_image_set_progress">
        <doc xml:whitespace="preserve">vips signals evaluation progress via the "preeval", "eval" and "posteval"
signals. Progress is signalled on the most-downstream image for which
vips_image_set_progress() was called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:whitespace="preserve">turn progress reporting on or off</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="vips_image_set_string">
        <doc xml:whitespace="preserve">Attaches @str as a metadata item on @image under the name @field. 
A convenience
function over vips_image_set() using an vips_ref_string.

See also: vips_image_get_double(), vips_image_set(), vips_ref_string</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:whitespace="preserve">metadata value</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wio_input" c:identifier="vips_image_wio_input">
        <doc xml:whitespace="preserve">Check that an image is readable via the VIPS_IMAGE_ADDR() macro, that is,
that the entire image is in memory and all pixels can be read with 
VIPS_IMAGE_ADDR().

If it 
isn't, try to transform it so that VIPS_IMAGE_ADDR() can work. 

See also: vips_image_wio_output(), vips_image_pio_input(), 
vips_image_inplace(), VIPS_IMAGE_ADDR().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on succeess, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="write" c:identifier="vips_image_write">
        <doc xml:whitespace="preserve">Write @image to @out. Use vips_image_new_mode() and friends to create the
#VipsImage you want to write to.

See also: vips_image_new_mode(), vips_copy(), vips_image_write_to_file().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">write to this image</doc>
            <type name="Image" c:type="VipsImage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_line" c:identifier="vips_image_write_line">
        <doc xml:whitespace="preserve">Write a line of pixels to an image. This function must be called repeatedly
with @ypos increasing from 0 to @YSize -
@linebuffer must be VIPS_IMAGE_SIZEOF_LINE() bytes long.

See also: vips_image_generate().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="ypos" transfer-ownership="none">
            <doc xml:whitespace="preserve">vertical position of scan-line to write</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="linebuffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">scanline of pixels</doc>
            <type name="Pel" c:type="VipsPel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_prepare" c:identifier="vips_image_write_prepare">
        <doc xml:whitespace="preserve">Call this after setting header fields (width, height, and so on) to
allocate resources ready for writing. 

Normally this function is called for you by vips_image_generate() or
vips_image_write_line(). You will need to call it yourself if you plan to
write directly to the -&gt;data member of a "t" image.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="write_to_file" c:identifier="vips_image_write_to_file">
        <doc xml:whitespace="preserve">A convenience function to write @image to a file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">write to this file</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="written" c:identifier="vips_image_written">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <property name="bands" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="coding" writable="1" transfer-ownership="none">
        <type name="Coding"/>
      </property>
      <property name="demand" writable="1" transfer-ownership="none">
        <type name="DemandStyle"/>
      </property>
      <property name="filename" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="foreign-buffer" writable="1" transfer-ownership="none">
        <type name="gpointer"/>
      </property>
      <property name="format" writable="1" transfer-ownership="none">
        <type name="BandFormat"/>
      </property>
      <property name="height" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="interpretation" writable="1" transfer-ownership="none">
        <type name="Interpretation"/>
      </property>
      <property name="kill" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="sizeof-header" writable="1" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="width" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="xoffset" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="xres" writable="1" transfer-ownership="none">
        <type name="gdouble"/>
      </property>
      <property name="yoffset" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="yres" writable="1" transfer-ownership="none">
        <type name="gdouble"/>
      </property>
      <glib:signal name="eval" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidate" when="last" action="1">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="minimise" when="last" action="1">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="posteval" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="preeval" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="written" when="last" action="1">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="ImageMapFn" c:type="VipsImageMapFn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="image" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="field" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ImageType"
                 glib:type-name="VipsImageType"
                 glib:get-type="vips_image_type_get_type"
                 c:type="VipsImageType">
      <member name="error"
              value="-1"
              c:identifier="VIPS_IMAGE_ERROR"
              glib:nick="error"/>
      <member name="none"
              value="0"
              c:identifier="VIPS_IMAGE_NONE"
              glib:nick="none"/>
      <member name="setbuf"
              value="1"
              c:identifier="VIPS_IMAGE_SETBUF"
              glib:nick="setbuf"/>
      <member name="setbuf_foreign"
              value="2"
              c:identifier="VIPS_IMAGE_SETBUF_FOREIGN"
              glib:nick="setbuf-foreign"/>
      <member name="openin"
              value="3"
              c:identifier="VIPS_IMAGE_OPENIN"
              glib:nick="openin"/>
      <member name="mmapin"
              value="4"
              c:identifier="VIPS_IMAGE_MMAPIN"
              glib:nick="mmapin"/>
      <member name="mmapinrw"
              value="5"
              c:identifier="VIPS_IMAGE_MMAPINRW"
              glib:nick="mmapinrw"/>
      <member name="openout"
              value="6"
              c:identifier="VIPS_IMAGE_OPENOUT"
              glib:nick="openout"/>
      <member name="partial"
              value="7"
              c:identifier="VIPS_IMAGE_PARTIAL"
              glib:nick="partial"/>
    </enumeration>
    <class name="Interpolate"
           c:symbol-prefix="interpolate"
           parent="Object"
           abstract="1"
           glib:type-name="VipsInterpolate"
           glib:get-type="vips_interpolate_get_type">
      <constructor name="new" c:identifier="vips_interpolate_new">
        <doc xml:whitespace="preserve">Look up an interpolator from a nickname and make one. You need to free the
result with g_object_unref() when you're done with it.

See also: vips_type_find().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an interpolator, or %NULL on error.</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:whitespace="preserve">nickname for interpolator</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bilinear_static"
                c:identifier="vips_interpolate_bilinear_static">
        <doc xml:whitespace="preserve">A convenience function that returns a bilinear interpolator you 
don't need to free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a bilinear interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <function name="nearest_static"
                c:identifier="vips_interpolate_nearest_static">
        <doc xml:whitespace="preserve">A convenience function that returns a nearest-neighbour interpolator you 
don't need to free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a nearest-neighbour interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </return-value>
      </function>
      <method name="" c:identifier="vips_interpolate" introspectable="0">
        <doc xml:whitespace="preserve">Look up the @interpolate method in the class and call it. Use
vips_interpolate_get_method() to get a direct pointer to the function and
avoid the lookup overhead.

You need to set @in and @out up correctly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="out" transfer-ownership="none">
            <doc xml:whitespace="preserve">write result here</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:whitespace="preserve">read source data from here</doc>
            <type c:type="VipsRegion*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">interpolate value at this position</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="vips_interpolate_get_method"
              introspectable="0">
        <doc xml:whitespace="preserve">Look up the @interpolate method in the class and return it. Use this
instead of vips_interpolate() to cache method dispatch.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to the interpolation function</doc>
          <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
        </return-value>
      </method>
      <method name="get_window_offset"
              c:identifier="vips_interpolate_get_window_offset">
        <doc xml:whitespace="preserve">Look up an interpolators desired window offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the interpolators required window offset</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_window_size"
              c:identifier="vips_interpolate_get_window_size">
        <doc xml:whitespace="preserve">Look up an interpolators desired window size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the interpolators required window size</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
    </class>
    <callback name="InterpolateMethod"
              c:type="VipsInterpolateMethod"
              introspectable="0">
      <doc xml:whitespace="preserve">An interpolation function. It should read source pixels from @in with
IM_REGION_ADDR(), it can look left and up from (x, y) by @window_offset
pixels and it can access pixels in a window of size @window_size.

The interpolated value should be written to the pixel pointed to by @out.

See also: #VipsInterpolateClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interpolator</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">write the interpolated pixel here</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">read source pixels from here</doc>
          <type c:type="VipsRegion*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">interpolate value at this position</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="Interpretation"
                 glib:type-name="VipsInterpretation"
                 glib:get-type="vips_interpretation_get_type"
                 c:type="VipsInterpretation">
      <doc xml:whitespace="preserve">How the values in an image should be interpreted. For example, a
three-band float image of type #VIPS_INTERPREATION_LAB should have its pixels
interpreted as coordinates in CIE Lab space.

These values are set by operations as hints to user-interfaces built on top 
of VIPS to help them show images to the user in a meaningful way. 
Operations do not use these values to decide their action.

The gaps in the numbering are historical and must be maintained. Allocate 
new numbers from the end.</doc>
      <member name="error"
              value="-1"
              c:identifier="VIPS_INTERPRETATION_ERROR"
              glib:nick="error"/>
      <member name="multiband"
              value="0"
              c:identifier="VIPS_INTERPRETATION_MULTIBAND"
              glib:nick="multiband"/>
      <member name="b_w"
              value="1"
              c:identifier="VIPS_INTERPRETATION_B_W"
              glib:nick="b-w"/>
      <member name="histogram"
              value="10"
              c:identifier="VIPS_INTERPRETATION_HISTOGRAM"
              glib:nick="histogram"/>
      <member name="fourier"
              value="24"
              c:identifier="VIPS_INTERPRETATION_FOURIER"
              glib:nick="fourier"/>
      <member name="xyz"
              value="12"
              c:identifier="VIPS_INTERPRETATION_XYZ"
              glib:nick="xyz"/>
      <member name="lab"
              value="13"
              c:identifier="VIPS_INTERPRETATION_LAB"
              glib:nick="lab"/>
      <member name="cmyk"
              value="15"
              c:identifier="VIPS_INTERPRETATION_CMYK"
              glib:nick="cmyk"/>
      <member name="labq"
              value="16"
              c:identifier="VIPS_INTERPRETATION_LABQ"
              glib:nick="labq"/>
      <member name="rgb"
              value="17"
              c:identifier="VIPS_INTERPRETATION_RGB"
              glib:nick="rgb"/>
      <member name="ucs"
              value="18"
              c:identifier="VIPS_INTERPRETATION_UCS"
              glib:nick="ucs"/>
      <member name="lch"
              value="19"
              c:identifier="VIPS_INTERPRETATION_LCH"
              glib:nick="lch"/>
      <member name="labs"
              value="21"
              c:identifier="VIPS_INTERPRETATION_LABS"
              glib:nick="labs"/>
      <member name="srgb"
              value="22"
              c:identifier="VIPS_INTERPRETATION_sRGB"
              glib:nick="srgb"/>
      <member name="yxy"
              value="23"
              c:identifier="VIPS_INTERPRETATION_YXY"
              glib:nick="yxy"/>
      <member name="rgb16"
              value="25"
              c:identifier="VIPS_INTERPRETATION_RGB16"
              glib:nick="rgb16"/>
      <member name="grey16"
              value="26"
              c:identifier="VIPS_INTERPRETATION_GREY16"
              glib:nick="grey16"/>
      <member name="array"
              value="27"
              c:identifier="VIPS_INTERPRETATION_ARRAY"
              glib:nick="array"/>
    </enumeration>
    <constant name="MAGIC_INTEL" value="3064394248" c:type="VIPS_MAGIC_INTEL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAGIC_SPARC" value="150120118" c:type="VIPS_MAGIC_SPARC">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="META_EXIF_NAME"
              value="exif-data"
              c:type="VIPS_META_EXIF_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_ICC_NAME"
              value="icc-profile-data"
              c:type="VIPS_META_ICC_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_RESOLUTION_UNIT"
              value="resolution-unit"
              c:type="VIPS_META_RESOLUTION_UNIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_XML" value="xml-header" c:type="VIPS_META_XML">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_XMP_NAME"
              value="xmp-data"
              c:type="VIPS_META_XMP_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="VipsObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="VipsObject"
           glib:get-type="vips_object_get_type"
           glib:type-struct="ObjectClass">
      <constructor name="new"
                   c:identifier="vips_object_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">g_object_new() the object, set any arguments with @set, call
vips_object_build() and return the complete object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new object</doc>
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">object to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:whitespace="preserve">set arguments with this</doc>
            <type name="ObjectSetArguments" c:type="VipsObjectSetArguments"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="vips_object_new_from_string">
        <return-value transfer-ownership="full">
          <type name="Object" c:type="VipsObject*"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="p" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_property" c:identifier="vips_object_get_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="map" c:identifier="vips_object_map" introspectable="0">
        <doc xml:whitespace="preserve">Call a function for all alive objects.
Stop when @fn returns non-%NULL and return that value. 

non-%NULL value from @fn.</doc>
        <return-value>
          <doc xml:whitespace="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="fn" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to call for all objects</doc>
            <type name="SListMap2Fn" c:type="VipsSListMap2Fn"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">client data</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="print_all" c:identifier="vips_object_print_all">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="print_summary_class"
                c:identifier="vips_object_print_summary_class">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="sanity_all" c:identifier="vips_object_sanity_all">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="set_property" c:identifier="vips_object_set_property">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="property_id" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="summary_class"
                c:identifier="vips_object_summary_class"
                introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <type name="ObjectClass" c:type="VipsObjectClass*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="build" invoker="build">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </virtual-method>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="dump" invoker="dump" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="output_to_arg">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="postclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="preclose" invoker="preclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="rewind" invoker="rewind">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="sanity" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary" invoker="summary" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="to_string" invoker="to_string" introspectable="0">
        <doc xml:whitespace="preserve">The inverse of vips_object_new_from_string(): turn an object into eg.
"VipsInterpolateSnohalo1(blur=.333333)".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="build" c:identifier="vips_object_build">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="dump" c:identifier="vips_object_dump" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument"
              c:identifier="vips_object_get_argument"
              introspectable="0">
        <doc xml:whitespace="preserve">Look up the three things you need to work with a vips argument.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">arg to fetch</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pspec for this arg</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </parameter>
          <parameter name="argument_class" transfer-ownership="none">
            <doc xml:whitespace="preserve">the argument_class for this arg</doc>
            <type c:type="VipsArgumentClass**"/>
          </parameter>
          <parameter name="argument_instance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the argument_instance for this arg</doc>
            <type c:type="VipsArgumentInstance**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_assigned"
              c:identifier="vips_object_get_argument_assigned">
        <doc xml:whitespace="preserve">Convenience: has an argument been assigned. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the argument has been assigned.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">arg to fetch</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_flags"
              c:identifier="vips_object_get_argument_flags">
        <doc xml:whitespace="preserve">Convenience: get the flags for an argument. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #VipsArgmentFlags for this argument.</doc>
          <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">arg to fetch</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_needs_string"
              c:identifier="vips_object_get_argument_needs_string">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_priority"
              c:identifier="vips_object_get_argument_priority">
        <doc xml:whitespace="preserve">Convenience: get the priority for an argument. Useful for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The priority of this argument.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">arg to fetch</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_argument_to_string"
              c:identifier="vips_object_get_argument_to_string">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="arg" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="local_array"
              c:identifier="vips_object_local_array"
              introspectable="0">
        <doc xml:whitespace="preserve">Make an array of NULL VipsObject pointers. When @parent closes, every
non-NULL pointer in the array will be unreffed and the arraqy will be
freed.
Handy for creating a 
set of temporary images for a function.

Example:

|[
VipsObject **t;

t = vips_object_local_array( a, 5 );
if( 
vips_add( a, b, &amp;t[0], NULL ) ||
vips_invert( t[0], &amp;t[1], NULL ) ||
vips_add( t[1], t[0], &amp;t[2], NULL ) ||
vips_costra( t[2], out, NULL ) )
return( -1 );
]|

See also: vips_object_local().</doc>
        <return-value>
          <doc xml:whitespace="preserve">an array of NULL pointers of length @n</doc>
          <type name="Object" c:type="VipsObject**"/>
        </return-value>
        <parameters>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">array size</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="local_cb" c:identifier="vips_object_local_cb">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gobject" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="preclose" c:identifier="vips_object_preclose">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="print_dump" c:identifier="vips_object_print_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="print_name" c:identifier="vips_object_print_name">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="print_summary" c:identifier="vips_object_print_summary">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="rewind" c:identifier="vips_object_rewind">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="sanity" c:identifier="vips_object_sanity">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set" c:identifier="vips_object_set" introspectable="0">
        <doc xml:whitespace="preserve">Set a list of vips object arguments. For example:

|[
vips_object_set (operation,
"input", in,
"output", &amp;out,
NULL);
]|

Input arguments are given in-line, output arguments are given as pointers
to where the output value should be written.

See also: vips_object_set_valist().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_argument_from_string"
              c:identifier="vips_object_set_argument_from_string">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_required" c:identifier="vips_object_set_required">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static" c:identifier="vips_object_set_static">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="static_object" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="vips_object_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">See vips_object_set().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">%NULL-terminated list of argument/value pairs</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="summary"
              c:identifier="vips_object_summary"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string"
              c:identifier="vips_object_to_string"
              introspectable="0">
        <doc xml:whitespace="preserve">The inverse of vips_object_new_from_string(): turn an object into eg.
"VipsInterpolateSnohalo1(blur=.333333)".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:whitespace="preserve">write string here</doc>
            <type c:type="VipsBuf*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_outputs" c:identifier="vips_object_unref_outputs">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="description" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="nickname" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent_object">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="constructed">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="static_object">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="preclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="postclose">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <glib:signal name="close" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="postclose" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="preclose" when="last">
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="VipsObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="build">
        <callback name="build">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary_class" introspectable="0">
        <callback name="summary_class" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary" introspectable="0">
        <callback name="summary" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dump" introspectable="0">
        <callback name="dump" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sanity" introspectable="0">
        <callback name="sanity" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rewind">
        <callback name="rewind">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preclose">
        <callback name="preclose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="postclose">
        <callback name="postclose">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_from_string" introspectable="0">
        <callback name="new_from_string" introspectable="0">
          <return-value>
            <type name="Object" c:type="VipsObject*"/>
          </return-value>
          <parameters>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="to_string" introspectable="0">
        <callback name="to_string" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="output_needs_arg">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="output_to_arg">
        <callback name="output_to_arg">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="VipsObject*"/>
            </parameter>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nickname">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="description">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="argument_table">
        <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
      </field>
      <field name="argument_table_traverse">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="argument_table_traverse_gtype">
        <type name="GType" c:type="GType"/>
      </field>
      <method name="install_argument"
              c:identifier="vips_object_class_install_argument">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ObjectSetArguments"
              c:type="VipsObjectSetArguments"
              introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Operation"
           c:symbol-prefix="operation"
           parent="Object"
           abstract="1"
           glib:type-name="VipsOperation"
           glib:get-type="vips_operation_get_type">
      <constructor name="new" c:identifier="vips_operation_new">
        <return-value transfer-ownership="full">
          <type name="Operation" c:type="VipsOperation*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="class_print_usage"
                c:identifier="vips_operation_class_print_usage"
                introspectable="0">
        <doc xml:whitespace="preserve">Print a usage message for the operation to stdout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="operation_class" transfer-ownership="none">
            <doc xml:whitespace="preserve">class to print usage for</doc>
            <type c:type="VipsOperationClass*"/>
          </parameter>
        </parameters>
      </function>
      <method name="call_valist"
              c:identifier="vips_operation_call_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="vips_operation_get_flags">
        <doc xml:whitespace="preserve">Returns the set of flags for this operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
          <type name="OperationFlags" c:type="VipsOperationFlags"/>
        </return-value>
      </method>
    </class>
    <enumeration name="OperationBoolean"
                 glib:type-name="VipsOperationBoolean"
                 glib:get-type="vips_operation_boolean_get_type"
                 c:type="VipsOperationBoolean">
      <doc xml:whitespace="preserve">See also: vips_boolean().</doc>
      <member name="and"
              value="0"
              c:identifier="VIPS_OPERATION_BOOLEAN_AND"
              glib:nick="and"/>
      <member name="or"
              value="1"
              c:identifier="VIPS_OPERATION_BOOLEAN_OR"
              glib:nick="or"/>
      <member name="eor"
              value="2"
              c:identifier="VIPS_OPERATION_BOOLEAN_EOR"
              glib:nick="eor"/>
      <member name="lshift"
              value="3"
              c:identifier="VIPS_OPERATION_BOOLEAN_LSHIFT"
              glib:nick="lshift"/>
      <member name="rshift"
              value="4"
              c:identifier="VIPS_OPERATION_BOOLEAN_RSHIFT"
              glib:nick="rshift"/>
      <member name="last"
              value="5"
              c:identifier="VIPS_OPERATION_BOOLEAN_LAST"
              glib:nick="last"/>
    </enumeration>
    <callback name="OperationBuildFn" c:type="VipsOperationBuildFn">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="OperationComplex"
                 glib:type-name="VipsOperationComplex"
                 glib:get-type="vips_operation_complex_get_type"
                 c:type="VipsOperationComplex">
      <doc xml:whitespace="preserve">See also: vips_complex().</doc>
      <member name="polar"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEX_POLAR"
              glib:nick="polar"/>
      <member name="rect"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEX_RECT"
              glib:nick="rect"/>
      <member name="conj"
              value="2"
              c:identifier="VIPS_OPERATION_COMPLEX_CONJ"
              glib:nick="conj"/>
      <member name="last"
              value="3"
              c:identifier="VIPS_OPERATION_COMPLEX_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="OperationComplexget"
                 glib:type-name="VipsOperationComplexget"
                 glib:get-type="vips_operation_complexget_get_type"
                 c:type="VipsOperationComplexget">
      <doc xml:whitespace="preserve">See also: vips_complexget().</doc>
      <member name="real"
              value="0"
              c:identifier="VIPS_OPERATION_COMPLEXGET_REAL"
              glib:nick="real"/>
      <member name="imag"
              value="1"
              c:identifier="VIPS_OPERATION_COMPLEXGET_IMAG"
              glib:nick="imag"/>
      <member name="last"
              value="2"
              c:identifier="VIPS_OPERATION_COMPLEXGET_LAST"
              glib:nick="last"/>
    </enumeration>
    <bitfield name="OperationFlags"
              glib:type-name="VipsOperationFlags"
              glib:get-type="vips_operation_flags_get_type"
              c:type="VipsOperationFlags">
      <doc xml:whitespace="preserve">Flags we associate with an operation.

@VIPS_OPERATION_SEQUENTIAL means that the operation works like vips_copy:
it can happily process images top-to-bottom with only small non-local
references.

@VIPS_OPERATION_NOCACHE means that the operation must not be cached by
vips.</doc>
      <member name="none"
              value="0"
              c:identifier="VIPS_OPERATION_NONE"
              glib:nick="none"/>
      <member name="sequential"
              value="1"
              c:identifier="VIPS_OPERATION_SEQUENTIAL"
              glib:nick="sequential"/>
      <member name="nocache"
              value="2"
              c:identifier="VIPS_OPERATION_NOCACHE"
              glib:nick="nocache"/>
    </bitfield>
    <enumeration name="OperationMath"
                 glib:type-name="VipsOperationMath"
                 glib:get-type="vips_operation_math_get_type"
                 c:type="VipsOperationMath">
      <doc xml:whitespace="preserve">See also: vips_math().</doc>
      <member name="sin"
              value="0"
              c:identifier="VIPS_OPERATION_MATH_SIN"
              glib:nick="sin"/>
      <member name="cos"
              value="1"
              c:identifier="VIPS_OPERATION_MATH_COS"
              glib:nick="cos"/>
      <member name="tan"
              value="2"
              c:identifier="VIPS_OPERATION_MATH_TAN"
              glib:nick="tan"/>
      <member name="asin"
              value="3"
              c:identifier="VIPS_OPERATION_MATH_ASIN"
              glib:nick="asin"/>
      <member name="acos"
              value="4"
              c:identifier="VIPS_OPERATION_MATH_ACOS"
              glib:nick="acos"/>
      <member name="atan"
              value="5"
              c:identifier="VIPS_OPERATION_MATH_ATAN"
              glib:nick="atan"/>
      <member name="log"
              value="6"
              c:identifier="VIPS_OPERATION_MATH_LOG"
              glib:nick="log"/>
      <member name="log10"
              value="7"
              c:identifier="VIPS_OPERATION_MATH_LOG10"
              glib:nick="log10"/>
      <member name="exp"
              value="8"
              c:identifier="VIPS_OPERATION_MATH_EXP"
              glib:nick="exp"/>
      <member name="exp10"
              value="9"
              c:identifier="VIPS_OPERATION_MATH_EXP10"
              glib:nick="exp10"/>
      <member name="last"
              value="10"
              c:identifier="VIPS_OPERATION_MATH_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="OperationMath2"
                 glib:type-name="VipsOperationMath2"
                 glib:get-type="vips_operation_math2_get_type"
                 c:type="VipsOperationMath2">
      <doc xml:whitespace="preserve">See also: vips_math().</doc>
      <member name="pow"
              value="0"
              c:identifier="VIPS_OPERATION_MATH2_POW"
              glib:nick="pow"/>
      <member name="wop"
              value="1"
              c:identifier="VIPS_OPERATION_MATH2_WOP"
              glib:nick="wop"/>
      <member name="last"
              value="2"
              c:identifier="VIPS_OPERATION_MATH2_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="OperationRelational"
                 glib:type-name="VipsOperationRelational"
                 glib:get-type="vips_operation_relational_get_type"
                 c:type="VipsOperationRelational">
      <doc xml:whitespace="preserve">See also: vips_relational().</doc>
      <member name="equal"
              value="0"
              c:identifier="VIPS_OPERATION_RELATIONAL_EQUAL"
              glib:nick="equal"/>
      <member name="notequal"
              value="1"
              c:identifier="VIPS_OPERATION_RELATIONAL_NOTEQUAL"
              glib:nick="notequal"/>
      <member name="less"
              value="2"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESS"
              glib:nick="less"/>
      <member name="lesseq"
              value="3"
              c:identifier="VIPS_OPERATION_RELATIONAL_LESSEQ"
              glib:nick="lesseq"/>
      <member name="more"
              value="4"
              c:identifier="VIPS_OPERATION_RELATIONAL_MORE"
              glib:nick="more"/>
      <member name="moreeq"
              value="5"
              c:identifier="VIPS_OPERATION_RELATIONAL_MOREEQ"
              glib:nick="moreeq"/>
      <member name="last"
              value="6"
              c:identifier="VIPS_OPERATION_RELATIONAL_LAST"
              glib:nick="last"/>
    </enumeration>
    <enumeration name="OperationRound"
                 glib:type-name="VipsOperationRound"
                 glib:get-type="vips_operation_round_get_type"
                 c:type="VipsOperationRound">
      <doc xml:whitespace="preserve">See also: vips_round().</doc>
      <member name="rint"
              value="0"
              c:identifier="VIPS_OPERATION_ROUND_RINT"
              glib:nick="rint"/>
      <member name="ceil"
              value="1"
              c:identifier="VIPS_OPERATION_ROUND_CEIL"
              glib:nick="ceil"/>
      <member name="floor"
              value="2"
              c:identifier="VIPS_OPERATION_ROUND_FLOOR"
              glib:nick="floor"/>
      <member name="last"
              value="3"
              c:identifier="VIPS_OPERATION_ROUND_LAST"
              glib:nick="last"/>
    </enumeration>
    <glib:boxed glib:name="RefString"
                c:symbol-prefix="ref_string"
                glib:type-name="VipsRefString"
                glib:get-type="vips_ref_string_get_type">
    </glib:boxed>
    <callback name="SListFold2Fn" c:type="VipsSListFold2Fn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap2Fn" c:type="VipsSListMap2Fn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SListMap4Fn" c:type="VipsSListMap4Fn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="SaveString"
                c:symbol-prefix="save_string"
                glib:type-name="VipsSaveString"
                glib:get-type="vips_save_string_get_type">
    </glib:boxed>
    <enumeration name="Saveable"
                 glib:type-name="VipsSaveable"
                 glib:get-type="vips_saveable_get_type"
                 c:type="VipsSaveable">
      <doc xml:whitespace="preserve">See also: #VipsForeignSave.</doc>
      <member name="mono"
              value="0"
              c:identifier="VIPS_SAVEABLE_MONO"
              glib:nick="mono"/>
      <member name="rgb"
              value="1"
              c:identifier="VIPS_SAVEABLE_RGB"
              glib:nick="rgb"/>
      <member name="rgba"
              value="2"
              c:identifier="VIPS_SAVEABLE_RGBA"
              glib:nick="rgba"/>
      <member name="rgb_cmyk"
              value="3"
              c:identifier="VIPS_SAVEABLE_RGB_CMYK"
              glib:nick="rgb-cmyk"/>
      <member name="any"
              value="4"
              c:identifier="VIPS_SAVEABLE_ANY"
              glib:nick="any"/>
      <member name="last"
              value="5"
              c:identifier="VIPS_SAVEABLE_LAST"
              glib:nick="last"/>
    </enumeration>
    <constant name="TRANSFORM_SCALE" value="1" c:type="VIPS_TRANSFORM_SCALE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="TRANSFORM_SHIFT" value="6" c:type="VIPS_TRANSFORM_SHIFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <glib:boxed glib:name="Thing"
                c:symbol-prefix="thing"
                glib:type-name="VipsThing"
                glib:get-type="vips_thing_get_type">
      <constructor name="new" c:identifier="vips_thing_new">
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #VipsThing.</doc>
          <type name="Thing" c:type="VipsThing*"/>
        </return-value>
        <parameters>
          <parameter name="i" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_i" c:identifier="vips_thing_get_i">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
    </glib:boxed>
    <enumeration name="Token"
                 glib:type-name="VipsToken"
                 glib:get-type="vips_token_get_type"
                 c:type="VipsToken">
      <doc xml:whitespace="preserve">Tokens returned by the vips lexical analyzer, see vips__token_get(). This
is used to parse option strings for arguments. 

Left and right brackets can be any of (, {, [, &lt;.

Strings may be in double quotes, and may contain escaped quote characters,
for example string, "string" and "str\"ing".</doc>
      <member name="left"
              value="1"
              c:identifier="VIPS_TOKEN_LEFT"
              glib:nick="left"/>
      <member name="right"
              value="2"
              c:identifier="VIPS_TOKEN_RIGHT"
              glib:nick="right"/>
      <member name="string"
              value="3"
              c:identifier="VIPS_TOKEN_STRING"
              glib:nick="string"/>
      <member name="equals"
              value="4"
              c:identifier="VIPS_TOKEN_EQUALS"
              glib:nick="equals"/>
      <member name="comma"
              value="5"
              c:identifier="VIPS_TOKEN_COMMA"
              glib:nick="comma"/>
    </enumeration>
    <callback name="TypeMap2Fn" c:type="VipsTypeMap2Fn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="TypeMapFn" c:type="VipsTypeMapFn" introspectable="0">
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="_Area" c:type="_VipsArea">
      <field name="data" writable="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" writable="1">
        <type name="gulong" c:type="size_t"/>
      </field>
      <field name="n" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="count" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="free_fn" readable="0" private="1">
        <type name="CallbackFn" c:type="VipsCallbackFn"/>
      </field>
      <field name="type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="sizeof_type" readable="0" private="1">
        <type name="gulong" c:type="size_t"/>
      </field>
    </record>
    <record name="_Argument" c:type="_VipsArgument">
      <field name="pspec" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </field>
    </record>
    <record name="_ArgumentClass" c:type="_VipsArgumentClass">
      <field name="parent" introspectable="0" writable="1">
        <type c:type="VipsArgument"/>
      </field>
      <field name="object_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ArgumentFlags" c:type="VipsArgumentFlags"/>
      </field>
      <field name="priority" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="_ArgumentInstance" c:type="_VipsArgumentInstance">
      <field name="parent" introspectable="0" writable="1">
        <type c:type="VipsArgument"/>
      </field>
      <field name="argument_class" introspectable="0" writable="1">
        <type c:type="VipsArgumentClass*"/>
      </field>
      <field name="object" writable="1">
        <type name="Object" c:type="VipsObject*"/>
      </field>
      <field name="assigned" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="close_id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
    </record>
    <record name="_Foreign" c:type="_VipsForeign">
      <field name="parent_object" writable="1">
        <type name="Operation" c:type="VipsOperation"/>
      </field>
    </record>
    <record name="_ForeignClass" c:type="_VipsForeignClass">
      <field name="parent_class" introspectable="0" writable="1">
        <type c:type="VipsOperationClass"/>
      </field>
      <field name="priority" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="suffs" writable="1">
        <type name="utf8" c:type="char**"/>
      </field>
    </record>
    <record name="_ForeignLoad" c:type="_VipsForeignLoad">
      <field name="parent_object" writable="1">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="disc" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="sequential" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </field>
      <field name="out" writable="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="real" writable="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="nocache" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <record name="_ForeignLoadClass" c:type="_VipsForeignLoadClass">
      <field name="parent_class" introspectable="0" writable="1">
        <type c:type="VipsForeignClass"/>
      </field>
      <field name="is_a">
        <callback name="is_a">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags_filename">
        <callback name="get_flags_filename">
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <type name="ForeignFlags" c:type="VipsForeignFlags"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header">
        <callback name="header">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load">
        <callback name="load">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="ForeignLoad" c:type="VipsForeignLoad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="_ForeignSave" c:type="_VipsForeignSave">
      <field name="parent_object" writable="1">
        <type name="Foreign" c:type="VipsForeign"/>
      </field>
      <field name="in" writable="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
      <field name="ready" writable="1">
        <type name="Image" c:type="VipsImage*"/>
      </field>
    </record>
    <record name="_ForeignSaveClass" c:type="_VipsForeignSaveClass">
      <field name="parent_class" introspectable="0" writable="1">
        <type c:type="VipsForeignClass"/>
      </field>
      <field name="saveable" writable="1">
        <type name="Saveable" c:type="VipsSaveable"/>
      </field>
      <field name="format_table" writable="1">
        <type name="BandFormat" c:type="VipsBandFormat*"/>
      </field>
      <field name="coding" writable="1">
        <array zero-terminated="0" c:type="gboolean">
          <type name="gboolean" c:type="gboolean"/>
        </array>
      </field>
    </record>
    <record name="_Image" c:type="_VipsImage">
      <field name="parent_object" writable="1">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="Xsize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Ysize" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Bands" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="BandFmt" readable="0" private="1">
        <type name="BandFormat" c:type="VipsBandFormat"/>
      </field>
      <field name="Coding" readable="0" private="1">
        <type name="Coding" c:type="VipsCoding"/>
      </field>
      <field name="Type" readable="0" private="1">
        <type name="Interpretation" c:type="VipsInterpretation"/>
      </field>
      <field name="Xres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Yres" readable="0" private="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="Xoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Yoffset" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Length" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Compression" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Level" readable="0" private="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="Bbits" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="time" introspectable="0" readable="0" private="1">
        <type c:type="VipsProgress*"/>
      </field>
      <field name="Hist" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="filename" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="data" readable="0" private="1">
        <type name="Pel" c:type="VipsPel*"/>
      </field>
      <field name="kill" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="Xres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="Yres_float" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="mode" readable="0" private="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="dtype" readable="0" private="1">
        <type name="ImageType" c:type="VipsImageType"/>
      </field>
      <field name="fd" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="baseaddr" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="length" readable="0" private="1">
        <type name="gulong" c:type="size_t"/>
      </field>
      <field name="magic" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="start_fn" introspectable="0">
        <callback name="start_fn" introspectable="0">
          <return-value>
            <type name="gpointer" c:type="void*"/>
          </return-value>
        </callback>
      </field>
      <field name="generate_fn">
        <callback name="generate_fn">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
        </callback>
      </field>
      <field name="stop_fn">
        <callback name="stop_fn">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
        </callback>
      </field>
      <field name="client1" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="client2" readable="0" private="1">
        <type name="gpointer" c:type="void*"/>
      </field>
      <field name="sslock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="regions" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="dhint" readable="0" private="1">
        <type name="DemandStyle" c:type="VipsDemandStyle"/>
      </field>
      <field name="meta" readable="0" private="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="meta_traverse" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="sizeof_header" readable="0" private="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="windows" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="upstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="downstream" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="serial" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="history_list" readable="0" private="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="progress_signal" writable="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
      <field name="file_length" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="hint_set" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="delete_on_close_filename" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
    </record>
    <record name="_ImageClass" c:type="_VipsImageClass">
      <field name="parent_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="preeval" introspectable="0">
        <callback name="preeval" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eval" introspectable="0">
        <callback name="eval" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="posteval" introspectable="0">
        <callback name="posteval" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type c:type="VipsProgress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="written">
        <callback name="written">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="gint" c:type="int*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="invalidate">
        <callback name="invalidate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="minimise">
        <callback name="minimise">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="image" transfer-ownership="none">
              <type name="Image" c:type="VipsImage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="_Interpolate" c:type="_VipsInterpolate">
      <field name="parent_object" writable="1">
        <type name="Object" c:type="VipsObject"/>
      </field>
    </record>
    <record name="_InterpolateClass" c:type="_VipsInterpolateClass">
      <field name="parent_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="interpolate" introspectable="0" writable="1">
        <type name="InterpolateMethod" c:type="VipsInterpolateMethod"/>
      </field>
      <field name="get_window_size">
        <callback name="get_window_size">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_size" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="get_window_offset">
        <callback name="get_window_offset">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Interpolate" c:type="VipsInterpolate*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="window_offset" writable="1">
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <record name="_Operation" c:type="_VipsOperation">
      <field name="parent_instance" writable="1">
        <type name="Object" c:type="VipsObject"/>
      </field>
      <field name="time" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="hash" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="found_hash" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <record name="_OperationClass" c:type="_VipsOperationClass">
      <field name="parent_class" writable="1">
        <type name="ObjectClass" c:type="VipsObjectClass"/>
      </field>
      <field name="usage" introspectable="0">
        <callback name="usage" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
            <parameter transfer-ownership="none">
              <type c:type="VipsBuf*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <type name="OperationFlags" c:type="VipsOperationFlags"/>
          </return-value>
          <parameters>
            <parameter transfer-ownership="none">
              <type name="Operation" c:type="VipsOperation*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flags" writable="1">
        <type name="OperationFlags" c:type="VipsOperationFlags"/>
      </field>
    </record>
    <record name="_Progress" c:type="_VipsProgress">
      <field name="im" writable="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
      <field name="run" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="eta" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="tpels" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="npels" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="percent" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="start" writable="1">
        <type name="GLib.Timer" c:type="GTimer*"/>
      </field>
    </record>
    <record name="_Thing" c:type="_VipsThing">
      <field name="i" writable="1">
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <function name="_argument_get_instance"
              c:identifier="vips__argument_get_instance"
              introspectable="0">
      <doc xml:whitespace="preserve">Convenience ... given the VipsArgumentClass, get the VipsArgumentInstance.</doc>
      <return-value>
        <type c:type="VipsArgumentInstance*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type c:type="VipsArgumentClass*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="_argument_table_lookup"
              c:identifier="vips__argument_table_lookup"
              introspectable="0">
      <return-value>
        <type c:type="VipsArgument*"/>
      </return-value>
      <parameters>
        <parameter transfer-ownership="none">
          <type name="ArgumentTable" c:type="VipsArgumentTable*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="_meta_init_types" c:identifier="vips__meta_init_types">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="_object_set_member" c:identifier="vips__object_set_member">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="member" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject**"/>
        </parameter>
        <parameter name="argument" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="abs" c:identifier="vips_abs" introspectable="0">
      <doc xml:whitespace="preserve">This operation finds the absolute value of an image. It does a copy for 
unsigned integer types, negate for negative values in 
signed integer types, &lt;function&gt;fabs(3)&lt;/function&gt; for 
float types, and calculates modulus for complex 
types. 

See also: vips_sign().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="acos" c:identifier="vips_acos" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_ACOS on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="add" c:identifier="vips_add" introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @in1 + @in2 and writes the result to @out. 

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), then the 
following table is used to determine the output type:

&lt;table&gt;
&lt;title&gt;VipsAdd type promotion&lt;/title&gt;
&lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;input type&lt;/entry&gt;
&lt;entry&gt;output type&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;uchar&lt;/entry&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;char&lt;/entry&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

Operations on integer images are performed using the processor's vector unit,
if possible. Disable this with --vips-novector or IM_NOVECTOR.

See also: vips_subtract(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="analyzeload"
              c:identifier="vips_analyzeload"
              introspectable="0">
      <doc xml:whitespace="preserve">Load an Analyze 6.0 file. If @filename is "fred.img", this will look for
an image header called "fred.hdr" and pixel data in "fred.img". You can
also load "fred" or "fred.hdr".

Images are
loaded lazilly and byte-swapped, if necessary. The Analyze metadata is read
and attached.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="andimage" c:identifier="vips_andimage" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="andimage_const"
              c:identifier="vips_andimage_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="andimage_const1"
              c:identifier="vips_andimage_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_AND on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="argument_class_map"
              c:identifier="vips_argument_class_map"
              introspectable="0">
      <doc xml:whitespace="preserve">And loop over a class. Same as ^^, but with no VipsArgumentInstance.</doc>
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <type name="ObjectClass" c:type="VipsObjectClass*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <type name="ArgumentClassMapFn" c:type="VipsArgumentClassMapFn"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="argument_map"
              c:identifier="vips_argument_map"
              introspectable="0">
      <doc xml:whitespace="preserve">Loop over the vips_arguments to an object. Stop when @fn returns non-%NULL
and return that value. 

non-%NULL value from @fn.</doc>
      <return-value>
        <doc xml:whitespace="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">object whose args should be enumerated</doc>
          <type name="Object" c:type="VipsObject*"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:whitespace="preserve">call this function for every argument</doc>
          <type name="ArgumentMapFn" c:type="VipsArgumentMapFn"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="array_double_get_type"
              c:identifier="vips_array_double_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="array_double_new" c:identifier="vips_array_double_new">
      <doc xml:whitespace="preserve">Allocate a new array of doubles and copy @array into it. Free with
vips_area_unref().

See also: #VipsArea.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A new #VipsArrayDouble.</doc>
        <type name="ArrayDouble" c:type="VipsArrayDouble*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of double</doc>
          <array length="1" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of doubles</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="asin" c:identifier="vips_asin" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_ASIN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="atan" c:identifier="vips_atan" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_ATAN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="avg" c:identifier="vips_avg" introspectable="0">
      <doc xml:whitespace="preserve">This operation finds the average value in an image. It operates on all 
bands of the input image: use vips_stats() if you need to calculate an 
average for each band. For complex images, return the average modulus.

See also: vips_stats(), vips_bandmean(), vips_deviate(), vips_rank()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output pixel average</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_iscomplex"
              c:identifier="vips_band_format_iscomplex"
              moved-to="BandFormat.iscomplex">
      <doc xml:whitespace="preserve">Return %TRUE if @fmt is one of the complex types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isfloat"
              c:identifier="vips_band_format_isfloat"
              moved-to="BandFormat.isfloat">
      <doc xml:whitespace="preserve">Return %TRUE if @format is one of the float types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isint"
              c:identifier="vips_band_format_isint"
              moved-to="BandFormat.isint">
      <doc xml:whitespace="preserve">Return %TRUE if @format is one of the integer types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="band_format_isuint"
              c:identifier="vips_band_format_isuint"
              moved-to="BandFormat.isuint">
      <doc xml:whitespace="preserve">Return %TRUE if @format is one of the unsigned integer types.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to test</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin" c:identifier="vips_bandjoin" introspectable="0">
      <doc xml:whitespace="preserve">Join a set of images together, bandwise. 

If the images
have n and m bands, then the output image will have n + m
bands, with the first n coming from the first image and the last m
from the second. 

If the images differ in size, the smaller images are enlarged to match the
larger by adding zero pixels along the bottom and right.

The input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of input images</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of input images</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="bandjoin2"
              c:identifier="vips_bandjoin2"
              introspectable="0">
      <doc xml:whitespace="preserve">Join a pair of images together, bandwise. See vips_bandjoin().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="bandmean" c:identifier="vips_bandmean" introspectable="0">
      <doc xml:whitespace="preserve">This operation writes a one-band image where each pixel is the average of 
the bands for that pixel in the input image. The output band format is 
the same as the input band format. Integer types use round-to-nearest
averaging.

See also: vips_add(), vips_avg(), vips_recomb()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #IMAGE</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #IMAGE</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="black" c:identifier="vips_black" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Make a black unsigned char image of a specified size.

See also: im_make_xy(), im_text(), im_gaussnoise().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">output width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">output height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="boolean" c:identifier="vips_boolean" introspectable="0">
      <doc xml:whitespace="preserve">Perform various boolean operations on pairs of images. 

The output image is the same format as the upcast input images for integer
types. Float types are cast to int before processing. Complex types are not
supported.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:whitespace="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="boolean_const"
              c:identifier="vips_boolean_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform various boolean operations on an image against an array of
constants.

The output type is always uchar, with 0 for FALSE and 255 for TRUE. 

If the array of constants has just one element, that constant is used for 
all image bands. If the array has more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="boolean" transfer-ownership="none">
          <doc xml:whitespace="preserve">boolean operation to perform</doc>
          <type name="OperationBoolean" c:type="VipsOperationBoolean"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cache" c:identifier="vips_cache" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation behaves rather like vips_copy() between images
@in and @out, except that it keeps a cache of computed pixels. 
This cache is made of up to @max_tiles tiles (a value of -1 
means any number of tiles), and each tile is of size @tile_width
by @tile_height pixels. By default it will cache 250 128 x 128 pixel tiles,
enough for two 1920 x 1080 images. 

This operation is a thin wrapper over vips_sink_screen(), see the
documentation for that operation for details. 

It uses a set of background threads to calculate pixels and the various
active cache operations coordinate so as not to overwhelm your system.

See also: vips_tilecache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cache_drop_all" c:identifier="vips_cache_drop_all">
      <doc xml:whitespace="preserve">Drop the whole operation cache, handy for leak tracking.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_get_max" c:identifier="vips_cache_get_max">
      <doc xml:whitespace="preserve">Get the maximum number of operations we keep in cache.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum number of operations we keep in cache</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_files"
              c:identifier="vips_cache_get_max_files">
      <doc xml:whitespace="preserve">Get the maximum number of tracked files we allow before we start dropping
cached operations. See vips_tracked_get_files().

See also: vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum number of tracked files we allow</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_get_max_mem" c:identifier="vips_cache_get_max_mem">
      <doc xml:whitespace="preserve">Get the maximum amount of tracked memory we allow before we start dropping
cached operations. See vips_tracked_get_mem().

See also: vips_tracked_get_mem().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum amount of tracked memory we allow</doc>
        <type name="gulong" c:type="size_t"/>
      </return-value>
    </function>
    <function name="cache_get_size" c:identifier="vips_cache_get_size">
      <doc xml:whitespace="preserve">Get the current number of operations in cache.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">get the current number of operations in cache.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
    </function>
    <function name="cache_operation_build"
              c:identifier="vips_cache_operation_build">
      <doc xml:whitespace="preserve">A binding-friendly version of vips_cache_operation_buildp().

After calling this, @operation has the same ref count as when it went in,
and the result must be freed with vips_object_unref_outputs() and
g_object_unref().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The built operation.</doc>
        <type name="Operation" c:type="VipsOperation*"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:whitespace="preserve">operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_operation_buildp"
              c:identifier="vips_cache_operation_buildp"
              introspectable="0">
      <doc xml:whitespace="preserve">Look up @operation in the cache. If we get a hit, unref @operation, ref the
old one and return that through the argument pointer. 

If we miss, build and add @operation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to operation to lookup</doc>
          <type name="Operation" c:type="VipsOperation**"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_print" c:identifier="vips_cache_print">
      <doc xml:whitespace="preserve">Print the whole operation cache to stdout. Handy for debugging.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cache_set_dump" c:identifier="vips_cache_set_dump">
      <doc xml:whitespace="preserve">Handy for debugging. Print the operation cache to stdout just before exit.

See also: vips_cache_set_trace().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dump" transfer-ownership="none">
          <doc xml:whitespace="preserve">if %TRUE, dump the operation cache on exit</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max" c:identifier="vips_cache_set_max">
      <doc xml:whitespace="preserve">Set the maximum number of operations we keep in cache.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum number of operation to cache</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_files"
              c:identifier="vips_cache_set_max_files">
      <doc xml:whitespace="preserve">Set the maximum number of tracked files we allow before we start dropping
cached operations. See vips_tracked_get_files().

See also: vips_tracked_get_files().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_files" transfer-ownership="none">
          <doc xml:whitespace="preserve">max open files we allow</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_max_mem" c:identifier="vips_cache_set_max_mem">
      <doc xml:whitespace="preserve">Set the maximum amount of tracked memory we allow before we start dropping
cached operations. See vips_tracked_get_mem().

See also: vips_tracked_get_mem().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum amount of tracked memory we use</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="cache_set_trace" c:identifier="vips_cache_set_trace">
      <doc xml:whitespace="preserve">Handy for debugging. Print operation cache actions to stdout as we run.

See also: vips_cache_set_dump().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="trace" transfer-ownership="none">
          <doc xml:whitespace="preserve">if %TRUE, trace the operation cache</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="call" c:identifier="vips_call" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="call_argv" c:identifier="vips_call_argv">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_options" c:identifier="vips_call_options">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="group" transfer-ownership="none">
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </parameter>
        <parameter name="operation" transfer-ownership="none">
          <type name="Operation" c:type="VipsOperation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="call_split"
              c:identifier="vips_call_split"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="operation_name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="optional" transfer-ownership="none">
          <type name="va_list" c:type="va_list"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast" c:identifier="vips_cast" introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to @format. You can convert between any pair of formats.
Floats are truncated (not rounded). Out of range values are clipped.

Casting from complex to real returns the real part. 

See also: im_scale(), im_ri2c().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to convert to</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_char"
              c:identifier="vips_cast_char"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_CHAR. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_complex"
              c:identifier="vips_cast_complex"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_COMPLEX. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_double"
              c:identifier="vips_cast_double"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_DOUBLE. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_dpcomplex"
              c:identifier="vips_cast_dpcomplex"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_DPCOMPLEX. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_float"
              c:identifier="vips_cast_float"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_FLOAT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_int" c:identifier="vips_cast_int" introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_INT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_short"
              c:identifier="vips_cast_short"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_SHORT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_uchar"
              c:identifier="vips_cast_uchar"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_UCHAR. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_uint"
              c:identifier="vips_cast_uint"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_UINT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cast_ushort"
              c:identifier="vips_cast_ushort"
              introspectable="0">
      <doc xml:whitespace="preserve">Convert @in to #VIPS_FORMAT_USHORT. See vips_cast().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="ceil" c:identifier="vips_ceil" introspectable="0">
      <doc xml:whitespace="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_CEIL. See 
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="check_8or16" c:identifier="vips_check_8or16">
      <doc xml:whitespace="preserve">Check that the image is 8 or 16-bit integer, signed or unsigned.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bandno" c:identifier="vips_check_bandno">
      <doc xml:whitespace="preserve">@bandno should be a valid band number (ie. 0 to im-&gt;Bands - 1), or can be
-1, meaning all bands. 
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bandno" transfer-ownership="none">
          <doc xml:whitespace="preserve">band number</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands" c:identifier="vips_check_bands">
      <doc xml:whitespace="preserve">Check that the image has @bands bands.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:whitespace="preserve">must have this many bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1or3" c:identifier="vips_check_bands_1or3">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn" c:identifier="vips_check_bands_1orn">
      <doc xml:whitespace="preserve">Check that the images have the same number of bands, or that one of the
images has just 1 band.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_1orn_unary"
              c:identifier="vips_check_bands_1orn_unary">
      <doc xml:whitespace="preserve">Check that an image has 1 or @n bands. Handy for unary operations, cf.
vips_check_bands_1orn().
If not, set an error message
and return non-zero.

See also: vips_check_bands_1orn().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of bands, or 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_bands_same" c:identifier="vips_check_bands_same">
      <doc xml:whitespace="preserve">Check that the images have the same number of bands.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_known" c:identifier="vips_check_coding_known">
      <doc xml:whitespace="preserve">Check that the image is uncoded, LABQ coded or RAD coded. 
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_labq" c:identifier="vips_check_coding_labq">
      <doc xml:whitespace="preserve">Check that the image is in LABQ coding. 
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_noneorlabq"
              c:identifier="vips_check_coding_noneorlabq">
      <doc xml:whitespace="preserve">Check that the image is uncoded or LABQ coded.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_rad" c:identifier="vips_check_coding_rad">
      <doc xml:whitespace="preserve">Check that the image is in Radiance coding. 
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_coding_same" c:identifier="vips_check_coding_same">
      <doc xml:whitespace="preserve">Check that the images have the same coding.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_complex" c:identifier="vips_check_complex">
      <doc xml:whitespace="preserve">Check that the image is complex.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_dmask"
              c:identifier="vips_check_dmask"
              introspectable="0">
      <doc xml:whitespace="preserve">Sanity-check a mask parameter.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">mask to check</doc>
          <type c:type="DOUBLEMASK*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_dmask_1d"
              c:identifier="vips_check_dmask_1d"
              introspectable="0">
      <doc xml:whitespace="preserve">A mask must be one-dimensional (width or height 1).

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">mask to check</doc>
          <type c:type="DOUBLEMASK*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format" c:identifier="vips_check_format">
      <doc xml:whitespace="preserve">Check that the image has the specified format.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">format to test for</doc>
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_format_same" c:identifier="vips_check_format_same">
      <doc xml:whitespace="preserve">Check that the images have the same format.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_hist" c:identifier="vips_check_hist">
      <doc xml:whitespace="preserve">Histogram images must have width or height 1, and must not have more than 
65536 elements. Return 0 if the image will pass as a histogram, or -1 and
set an error message otherwise.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_imask"
              c:identifier="vips_check_imask"
              introspectable="0">
      <doc xml:whitespace="preserve">Sanity-check a mask parameter.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="mask" transfer-ownership="none">
          <doc xml:whitespace="preserve">mask to check</doc>
          <type c:type="INTMASK*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_init" c:identifier="vips_check_init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="check_int" c:identifier="vips_check_int">
      <doc xml:whitespace="preserve">Check that the image is in one of the integer formats.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_mono" c:identifier="vips_check_mono">
      <doc xml:whitespace="preserve">Check that the image has exactly one band.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_noncomplex" c:identifier="vips_check_noncomplex">
      <doc xml:whitespace="preserve">Check that the image is not complex.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_size_same" c:identifier="vips_check_size_same">
      <doc xml:whitespace="preserve">Check that the images have the same size.
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="im2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16" c:identifier="vips_check_u8or16">
      <doc xml:whitespace="preserve">Check that the image is 8 or 16-bit unsigned integer.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_u8or16orf" c:identifier="vips_check_u8or16orf">
      <doc xml:whitespace="preserve">Check that the image is 8 or 16-bit unsigned integer, or float.
Otherwise set an error message and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uint" c:identifier="vips_check_uint">
      <doc xml:whitespace="preserve">Check that the image is in one of the unsigned integer formats.
Otherwise set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uintorf" c:identifier="vips_check_uintorf">
      <doc xml:whitespace="preserve">Check that the image is unsigned int or float.
Otherwise set an error message and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_uncoded" c:identifier="vips_check_uncoded">
      <doc xml:whitespace="preserve">Check that the image is not coded. 
If not, set an error message
and return non-zero.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on OK, or -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="check_vector" c:identifier="vips_check_vector">
      <doc xml:whitespace="preserve">Operations with a vector constant need a 1-element vector, or a vector with
the same number of elements as there are bands in the image.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if OK, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the originating domain for the error message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of elements in vector</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to check against</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_find"
              c:identifier="vips_class_find"
              introspectable="0">
      <doc xml:whitespace="preserve">Search below basename, return the first class whose name or nickname
matches.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the found class.</doc>
        <type name="ObjectClass" c:type="VipsObjectClass*"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of base class</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <doc xml:whitespace="preserve">search for a class with this nickname</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="class_map_all"
              c:identifier="vips_class_map_all"
              introspectable="0">
      <doc xml:whitespace="preserve">Loop over all the subclasses of a base type. Non-abstract classes only.</doc>
      <return-value>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <type name="ClassMapFn" c:type="VipsClassMapFn"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="complex" c:identifier="vips_complex" introspectable="0">
      <doc xml:whitespace="preserve">Perform various operations on complex images.

Angles are expressed in degrees. The output type is complex unless the 
input is double or dpcomplex, in which case the output is dpcomplex.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="cmplx" transfer-ownership="none">
          <doc xml:whitespace="preserve">complex operation to perform</doc>
          <type name="OperationComplex" c:type="VipsOperationComplex"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="complexform"
              c:identifier="vips_complexform"
              introspectable="0">
      <doc xml:whitespace="preserve">Compose two real images to make a complex image. If either @left or @right 
are #VIPS_FORMAT_DOUBLE, @out is #VIPS_FORMAT_DPCOMPLEX. Otherwise @out 
is #VIPS_FORMAT_COMPLEX. @left becomes the real component of @out and 
@right the imaginary.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

See also: vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="complexget"
              c:identifier="vips_complexget"
              introspectable="0">
      <doc xml:whitespace="preserve">Get components of complex images. 

The output type is the same as the input type, except #VIPS_FORMAT_COMPLEX
becomes #VIPS_FORMAT_FLOAT and #VIPS_FORMAT_DPCOMPLEX becomes 
#VIPS_FORMAT_DOUBLE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="get" transfer-ownership="none">
          <doc xml:whitespace="preserve">complex operation to perform</doc>
          <type name="OperationComplexget" c:type="VipsOperationComplexget"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="conj" c:identifier="vips_conj" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_COMPLEX_CONJ on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="copy" c:identifier="vips_copy" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Copy an image, optionally modifying the header. VIPS copies images by 
copying pointers, so this operation is instant, even for very large images.

You can optionally set any or all header fields during the copy. Some
header fields, such as "xres", the horizontal resolution, are safe to
change in any way, others, such as "width" will cause immediate crashes if
they are not set carefully. 

Setting @swap to %TRUE will make vips_copy() swap the byte ordering of
pixels according to the image's format.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="copy_file" c:identifier="im_copy_file">
      <doc xml:whitespace="preserve">Copy an image to a disc file, then copy again to output. If the image is
already a disc file, just copy straight through.

The disc file is allocated in the same way as im_system_image(). 
The file is automatically deleted when @out is closed.

See also: im_copy(), im_system_image().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cos" c:identifier="vips_cos" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_COS on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="cross_phase" c:identifier="im_cross_phase">
      <doc xml:whitespace="preserve">Find the phase of the cross power spectrum of two complex images,
expressed as a complex image where the modulus of each pixel is
one.

I.E. find (a.b*)/|a.b*| where
.  represents complex multiplication
*  represents the complex conjugate
|| represents the complex modulus

See also: im_multiply(), im_sign().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #IMAGE 1</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #IMAGE 2</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #IMAGE</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="csvload" c:identifier="vips_csvload" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Load a CSV (comma-separated values) file. The output image is always 1 
band (monochrome), #VIPS_FORMAT_DOUBLE. 

Items in lines can be either floating point numbers in the C locale, or 
strings enclosed in double-quotes ("), or empty.
You can use a backslash (\) within the quotes to escape special characters,
such as quote marks.

The reader is deliberately rather fussy: it will fail if there are any 
short lines, or if the file is too short. It will ignore lines that are 
too long.

@skip sets the number of lines to skip at the start of the file. 
Default zero.

@lines sets the number of lines to read from the file. Default -1, 
meaning read all lines to end of file.

@whitespace sets the skippable whitespace characters. 
Default &lt;emphasis&gt;space&lt;/emphasis&gt;.
Whitespace characters are always run together.

@separator sets the characters that separate fields. 
Default ;,&lt;emphasis&gt;tab&lt;/emphasis&gt;. Separators are never run together.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="csvsave" c:identifier="vips_csvsave" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Writes the pixels in @in to the @filename as CSV (comma-separated values).
The image is written
one line of text per scanline. Complex numbers are written as 
"(real,imaginary)" and will need extra parsing I guess. Only the first band
is written. 

@separator gives the string to use to separate numbers in the output. 
The default is "\\t" (tab).

See also: vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="deviate" c:identifier="vips_deviate" introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="diag" c:identifier="vips_diag" introspectable="0">
      <doc xml:whitespace="preserve">Sends a formatted diagnostic message to stderr. If you define the
environment variable IM_DIAGNOSTICS, these message are surpressed.

Diagnostic messages are used to report details about the operation of
functions.

See also: vips_vdiag(), vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the diagnostic message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="divide" c:identifier="vips_divide" introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @in1 / @in2 and writes the result to @out. If any
pixels in @in2 are zero, the corresponding pixel in @out is also zero.

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), then the 
following table is used to determine the output type:

&lt;table&gt;
&lt;title&gt;im_divide() type promotion&lt;/title&gt;
&lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;input type&lt;/entry&gt;
&lt;entry&gt;output type&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;uchar&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;char&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_multiply(), vips_linear(), vips_power().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="embed" c:identifier="vips_embed" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


The opposite of vips_extract_area(): embed @in within an image of size 
@width by @height at position @x, @y.  @extend
controls what appears in the new pels, see #VipsExtend. 

See also: vips_extract_area(), vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">place @in at this x position in @out</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">place @in at this y position in @out</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">@out should be this many pixels across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">@out should be this many pixels down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage" c:identifier="vips_eorimage" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage_const"
              c:identifier="vips_eorimage_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="eorimage_const1"
              c:identifier="vips_eorimage_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_EOR on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="equal" c:identifier="vips_equal" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="equal_const"
              c:identifier="vips_equal_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="equal_const1"
              c:identifier="vips_equal_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_EQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="error" c:identifier="vips_error" introspectable="0">
      <doc xml:whitespace="preserve">Format the string in the style of printf() and append to the error buffer.

See also: vips_error_system(), vips_verror().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="error_buffer" c:identifier="vips_error_buffer">
      <doc xml:whitespace="preserve">Get a pointer to the start of the error buffer as a C string.
The string is owned by the error system and must not be freed.

See also: vips_error_clear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error buffer as a C string which must not be freed</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="error_clear" c:identifier="vips_error_clear">
      <doc xml:whitespace="preserve">Clear and reset the error buffer. This is typically called after presenting
an error to the user.

See also: vips_error_buffer().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_exit"
              c:identifier="vips_error_exit"
              introspectable="0">
      <doc xml:whitespace="preserve">Sends a formatted error message to stderr, then sends the contents of the
error buffer, if any, then shuts down vips and terminates the program with 
an error code.

@fmt may be %NULL, in which case only the error buffer is printed before
exiting.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="error_g" c:identifier="vips_error_g" throws="1">
      <doc xml:whitespace="preserve">This function sets the glib error pointer from the vips error buffer and
clears it. It's handy for returning errors to glib functions from vips.

See also: g_set_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_system"
              c:identifier="vips_error_system"
              introspectable="0">
      <doc xml:whitespace="preserve">Format the string in the style of printf() and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

See also: vips_verror_system().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:whitespace="preserve">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="exp" c:identifier="vips_exp" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_EXP on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="exp10" c:identifier="vips_exp10" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_EXP10 on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="extract_area"
              c:identifier="vips_extract_area"
              introspectable="0">
      <doc xml:whitespace="preserve">Extract an area from an image. The area must fit within @in.

See also: vips_extract_bands().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="input" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="output" transfer-ownership="none">
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:whitespace="preserve">top edge of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">width of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">height of area to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="extract_band"
              c:identifier="vips_extract_band"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Extract a band or bands from an image. Extracting out of range is an error.

See also: vips_extract_area().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="input" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="output" transfer-ownership="none">
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">band to extract</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="falsecolour" c:identifier="im_falsecolour">
      <doc xml:whitespace="preserve">Force @in to 1 band, 8-bit, then transform to 
3-band 8-bit image with a false colour
map. The map is supposed to make small differences in brightness more
obvious.

See also: im_maplut().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="fitsload" c:identifier="vips_fitsload" introspectable="0">
      <doc xml:whitespace="preserve">Read a FITS image file into a VIPS image. 

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="fitssave" c:identifier="vips_fitssave" introspectable="0">
      <doc xml:whitespace="preserve">Write a VIPS image to a file as FITS.

See also: vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="flatten" c:identifier="vips_flatten" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Take the last band of @in as an alpha and use it to blend the
remaining channels with @background. 

The alpha channel is 0 - 255 for
integer images and 0 - 1 for float images, where 255 means 100% image and 0
means 100% background.  Non-complex images only.
@background defaults to zero (black).

Useful for flattening PNG images to RGB.

See also: pngload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="flip" c:identifier="vips_flip" introspectable="0">
      <doc xml:whitespace="preserve">Flips an image left-right or up-down.

See also: vips_rot().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:whitespace="preserve">flip horizontally or vertically</doc>
          <type name="Direction" c:type="VipsDirection"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="floor" c:identifier="vips_floor" introspectable="0">
      <doc xml:whitespace="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_FLOOR. See 
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="foreign_flags" c:identifier="vips_foreign_flags">
      <doc xml:whitespace="preserve">Return the flags for @filename using @loader. 
@loader is something like "tiffload" or "VipsForeignLoadTiff".</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the flags for @filename.</doc>
        <type name="ForeignFlags" c:type="VipsForeignFlags"/>
      </return-value>
      <parameters>
        <parameter name="loader" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of loader to use for test</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to test</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="foreign_load"
              c:identifier="vips_foreign_load"
              introspectable="0">
      <doc xml:whitespace="preserve">Loads @filename into @out using the loader recommended by
vips_foreign_find_load().

See also: vips_foreign_save(), vips_foreign_load_options().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="foreign_save"
              c:identifier="vips_foreign_save"
              introspectable="0">
      <doc xml:whitespace="preserve">Saves @in to @filename using the saver recommended by
vips_foreign_find_save(). Options are not in @filename but must be given
as a NULL-terminated list of name-value pairs.

See also: vips_foreign_load().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="format_sizeof" c:identifier="vips_format_sizeof">
      <return-value transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <type name="BandFormat" c:type="VipsBandFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="gaussnoise" c:identifier="im_gaussnoise">
      <doc xml:whitespace="preserve">Make a one band float image of gaussian noise with the specified
distribution. The noise distribution is created by averaging 12 random 
numbers with the appropriate weights.

See also: im_addgnoise(), im_make_xy(), im_text(), im_black().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">output width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">output height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="mean" transfer-ownership="none">
          <doc xml:whitespace="preserve">average value in output</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="sigma" transfer-ownership="none">
          <doc xml:whitespace="preserve">standard deviation in output</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_argv0" c:identifier="vips_get_argv0">
      <doc xml:whitespace="preserve">See also: vips_init().

vips_init(). Do not free this value</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a pointer to an internal copy of the argv0 string passed to</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="get_option_group"
              c:identifier="vips_get_option_group"
              introspectable="0">
      <doc xml:whitespace="preserve">vips_get_option_group()  returns  a GOptionGroup containing various VIPS
command-line options. It  can  be  used  with  GOption  to  help
parse argc/argv.

See also: vips_version(), vips_guess_prefix(),
vips_guess_libdir(), vips_init().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a GOptionGroup for VIPS, see GOption</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="grid" c:identifier="im_grid">
      <doc xml:whitespace="preserve">Chop a tall thin image up into a set of tiles, lay the tiles out in a grid. 

The input image should be a very tall, thin image containing a list of
smaller images. Volumetric or time-sequence images are often laid out like
this. This image is chopped into a series of tiles, each @tile_height
pixels high and the width of @in. The tiles are then rearranged into a grid
@across tiles across and @down tiles down in row-major order.

See also: im_embed(), im_insert(), im_lrjoin().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="tile_height" transfer-ownership="none">
          <doc xml:whitespace="preserve">chop into tiles this high</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="across" transfer-ownership="none">
          <doc xml:whitespace="preserve">tiles across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="down" transfer-ownership="none">
          <doc xml:whitespace="preserve">tiles down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_libdir" c:identifier="vips_guess_libdir">
      <doc xml:whitespace="preserve">vips_guess_libdir() tries to guess the install directory (usually the 
configure libdir, or $prefix/lib). You should pass 
in the value of argv[0] (the name your program was run as) as a clue to 
help it out, plus the name of the environment variable you let the user 
override your package install area with (eg. "VIPSHOME"). 

On success, vips_guess_libdir() returns the libdir it discovered, and as a 
side effect, sets the prefix environment variable (if it's not set).

Don't free the return string!

See also: vips_guess_prefix().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the libdir as a static string, do not free.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:whitespace="preserve">program name (typically argv[0])</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">save prefix in this environment variable</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="guess_prefix" c:identifier="vips_guess_prefix">
      <doc xml:whitespace="preserve">vips_guess_prefix() tries to guess the install directory. You should pass 
in the value of argv[0] (the name your program was run as) as a clue to 
help it out, plus the name of the environment variable you let the user 
override your package install area with (eg. "VIPSHOME"). 

On success, vips_guess_prefix() returns the prefix it discovered, and as a 
side effect, sets the environment variable (if it's not set).

Don't free the return string!

See also: vips_guess_libdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the install prefix as a static string, do not free.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:whitespace="preserve">program name (typically argv[0])</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="env_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">save prefix in this environment variable</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ifthenelse"
              c:identifier="vips_ifthenelse"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation scans the condition image @cond 
and uses it to select pixels from either the then image @in1 or the else
image @in2. Non-zero means @in1, 0 means @in2.

Any image can have either 1 band or n bands, where n is the same for all
the non-1-band images. Single band images are then effectively copied to 
make n-band images.

Images @in1 and @in2 are cast up to the smallest common format. @cond is
cast to uchar.

If the images differ in size, the smaller images are enlarged to match the
largest by adding zero pixels along the bottom and right.

If @blend is %TRUE, then values in @out are smoothly blended between @in1
and @in2 using the formula:

@out = (@cond / 255) * @in1 + (1 - @cond / 255) * @in2

See also: vips_equal().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="cond" transfer-ownership="none">
          <doc xml:whitespace="preserve">condition #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:whitespace="preserve">then #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:whitespace="preserve">else #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="imag" c:identifier="vips_imag" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_COMPLEXGET_IMAG on an image. See vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="vips_init">
      <doc xml:whitespace="preserve">vips_init() starts up the world of VIPS. You should call this on
program startup before using any other VIPS operations. If you do not call
vips_init(), VIPS will call it for you when you use your first VIPS 
operation, but
it may not be able to get hold of @argv0 and VIPS may therefore be unable
to find its data files. It is much better to call this function yourself.

vips_init() does approximately the following:

&lt;itemizedlist&gt;
&lt;listitem&gt; 
&lt;para&gt;initialises any libraries that VIPS is using, including GObject
and the threading system, if neccessary&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;guesses where the VIPS data files are and sets up
internationalisation --- see vips_guess_prefix()
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;creates the main vips types, including VipsImage and friends
&lt;/para&gt;
&lt;/listitem&gt;
&lt;listitem&gt; 
&lt;para&gt;loads any plugins from $libdir/vips-x.y, where x and y are the
major and minor version numbers for this VIPS.
&lt;/para&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Example:

|[
int main( int argc, char **argv )
{
if( vips_init( argv[0] ) )
vips_error_exit( "unable to start VIPS" );

vips_shutdown();

return( 0 );
}
]|

See also: vips_shutdown(), vips_get_option_group(), vips_version(), 
vips_guess_prefix(), vips_guess_libdir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 otherwise</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="argv0" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of application</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="insert" c:identifier="vips_insert" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Insert one image into another. @sub is inserted into image @main at
position @x, @y relative to the top LH corner of @main. 

Normally @out shows the whole of @main. If @expand is #TRUE then @out is
made large enough to hold all of @main and @sub. 
Any areas of @out not coming from
either @main or @sub are set to @background (default 0).

If @sub overlaps @main,
@sub will appear on top of @main. 

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_join(), vips_embed(), vips_extract_area().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="main" transfer-ownership="none">
          <doc xml:whitespace="preserve">big image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="sub" transfer-ownership="none">
          <doc xml:whitespace="preserve">small image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">left position of @sub</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">top position of @sub</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="insertset" c:identifier="im_insertset">
      <doc xml:whitespace="preserve">Insert @sub repeatedly into @main at the positions listed in the arrays @x,
@y of length @n. @out is the same
size as @main. @sub is clipped against the edges of @main. 

This operation is fast for large @n, but will use a memory buffer the size
of @out. It's useful for things like making scatter plots.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: im_insert(), im_lrjoin().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="main" transfer-ownership="none">
          <doc xml:whitespace="preserve">big image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="sub" transfer-ownership="none">
          <doc xml:whitespace="preserve">small image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of positions</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">left positions of @sub</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">top positions of @sub</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="invert" c:identifier="vips_invert" introspectable="0">
      <doc xml:whitespace="preserve">For unsigned formats, this operation calculates (max - @in), eg. (255 -
@in) for uchar. For signed and float formats, this operation calculates (-1
* @in). 

See also: vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="join" c:identifier="vips_join" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Join @in1 and @in2 together, left-right or up-down depending on the value 
of @direction.

If one is taller or wider than the
other, @out will be has high as the smaller. If @expand is %TRUE, then
the output will be expanded to contain all of the input pixels.

Use @align to set the edge that the images align on. By default, they align
on the edge with the lower value coordinate.

Use @background to set the colour of any pixels in @out which are not
present in either @in1 or @in2.

Use @shim to set the spacing between the images. By default this is 0.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_insert().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="main" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="sub" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:whitespace="preserve">join horizontally or vertically</doc>
          <type name="Direction" c:type="VipsDirection"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload" c:identifier="vips_jpegload" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Read a JPEG file into a VIPS image. It can read most 8-bit JPEG images, 
including CMYK and YCbCr.

@shrink means shrink by this integer factor during load.  Possible values 
are 1, 2, 4 and 8. Shrinking during read is very much faster than 
decompressing the whole image and then shrinking later.

Setting @fail to true makes the JPEG reader fail on any warnings. 
This can be useful for detecting truncated files, for example. Normally 
reading these produces a warning, but no fatal error.  

Example:

|[
vips_jpegload( "fred.jpg", &amp;out,
"shrink", 8,
"fail", TRUE,
NULL );
]|

Any embedded ICC profiles are ignored: you always just get the RGB from 
the file. Instead, the embedded profile will be attached to the image as 
metadata.  You need to use something like im_icc_import() to get CIE 
values from the file. Any EXIF data is also attached as VIPS metadata.

The int metadata item "jpeg-multiscan" is set to the result of 
jpeg_has_multiple_scans(). Interlaced jpeg images need a large amount of
memory to load, so this field gives callers a chance to handle these
images differently.

The EXIF thumbnail, if present, is attached to the image as 
"jpeg-thumbnail-data". See vips_image_get_blob().

This function only reads the image header and does not decompress any pixel
data. Decompression only occurs when pixels are accessed by some other
function.

See also: vips_jpegload_buffer(), vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="jpegload_buffer"
              c:identifier="vips_jpegload_buffer"
              introspectable="0">
      <doc xml:whitespace="preserve">Read a JPEG-formatted memory block into a VIPS image. It can read most 
8-bit JPEG images, including CMYK and YCbCr.

This function is handy for processing JPEG image thumbnails.

Caution: on return only the header will have been read, the pixel data is
not decompressed until the first pixel is read. Therefore you must not free
@buf until you have read pixel data from @out.

See also: vips_jpegload().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">memory area to load</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of memory area</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to write</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave" c:identifier="vips_jpegsave" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Write a VIPS image to a file as JPEG.

Use @Q to set the JPEG compression factor. Default 75.

Use @profile to give the filename of a profile to be em,bedded in the JPEG.
This does not affect the pixels which are written, just the way 
they are tagged. You can use the special string "none" to mean 
"don't attach a profile".

If no profile is specified and the VIPS header 
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

The image is automatically converted to RGB, Monochrome or CMYK before 
saving. Any metadata attached to the image is saved as EXIF, if possible.

See also: vips_jpegsave_buffer(), vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave_buffer"
              c:identifier="vips_jpegsave_buffer"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


As vips_jpegsave(), but save to a memory buffer. 

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with g_free() when you
are done with it.

See also: vips_jpegsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">return output buffer here</doc>
          <type name="gpointer" c:type="void**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">return output length here</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="jpegsave_mime"
              c:identifier="vips_jpegsave_mime"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


As vips_jpegsave(), but save as a mime jpeg on stdout.

See also: vips_jpegsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="less" c:identifier="vips_less" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="less_const"
              c:identifier="vips_less_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="less_const1"
              c:identifier="vips_less_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESS on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq" c:identifier="vips_lesseq" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq_const"
              c:identifier="vips_lesseq_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lesseq_const1"
              c:identifier="vips_lesseq_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_LESSEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="linear" c:identifier="vips_linear" introspectable="0">
      <doc xml:whitespace="preserve">Pass an image through a linear transform, ie. (@out = @in * @a + @b). Output
is always float for integer input, double for double input, complex for
complex input and double complex for double complex input.

If the arrays of constants have just one element, that constant is used for 
all image bands. If the arrays have more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_linear1(), vips_add().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to transform</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants for multiplication</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants for addition</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">length of constant arrays</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="linear1" c:identifier="vips_linear1" introspectable="0">
      <doc xml:whitespace="preserve">Run vips_linear() with a single constant. 

See also: vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to transform</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant for multiplication</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant for addition</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="linreg" c:identifier="im_linreg">
      <doc xml:whitespace="preserve">Function to find perform pixelwise linear regression on an array of 
single band images. The output is a seven-band douuble image

TODO: figure out how this works and fix up these docs!</doc>
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="ins" transfer-ownership="none">
          <doc xml:whitespace="preserve">NULL-terminated array of input images</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">results of analysis</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xs" transfer-ownership="none">
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="log" c:identifier="vips_log" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_LOG on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="log10" c:identifier="vips_log10" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_LOG10 on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lshift" c:identifier="vips_lshift" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lshift_const"
              c:identifier="vips_lshift_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="lshift_const1"
              c:identifier="vips_lshift_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="magickload"
              c:identifier="vips_magickload"
              introspectable="0">
      <doc xml:whitespace="preserve">Read in an image using libMagick, the ImageMagick library. This library can
read more than 80 file formats, including SVG, BMP, EPS, DICOM and many 
others.
The reader can handle any ImageMagick image, including the float and double
formats. It will work with any quantum size, including HDR. Any metadata
attached to the libMagick image is copied on to the VIPS image.

The reader should also work with most versions of GraphicsMagick. See the
"--with-magickpackage" configure option.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="math" c:identifier="vips_math" introspectable="0">
      <doc xml:whitespace="preserve">Perform various functions in -lm, the maths library, on images. 

Angles are expressed in degrees. The output type is float unless the 
input is double, in which case the output is double.  

Non-complex images only.

See also: vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math" transfer-ownership="none">
          <doc xml:whitespace="preserve">math operation to perform</doc>
          <type name="OperationMath" c:type="VipsOperationMath"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="math2" c:identifier="vips_math2" introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates a 2-ary maths operation on a pair of images
and writes the result to @out. The images may have any 
non-complex format. @out is float except in the case that either of @left
or @right are double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output. 
Beware: it does this silently!

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), and that format is the
result type.

See also: vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:whitespace="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="math2_const"
              c:identifier="vips_math2_const"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates various 2-ary maths operations on an image and 
an array of constants and writes the result to @out. 
The image may have any 
non-complex format. @out is float except in the case that @in
is double, in which case @out is also double.

It detects division by zero, setting those pixels to zero in the output. 
Beware: it does this silently!

If the array of constants has just one element, that constant is used for 
all image bands. If the array has more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_math2(), vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:whitespace="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="math2_const1"
              c:identifier="vips_math2_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates various 2-ary maths operations on an image and 
a constant. See vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="math2" transfer-ownership="none">
          <doc xml:whitespace="preserve">math operation to perform</doc>
          <type name="OperationMath2" c:type="VipsOperationMath2"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="matload" c:identifier="vips_matload" introspectable="0">
      <doc xml:whitespace="preserve">Read a Matlab save file into a VIPS image. 

This operation searches the save
file for the first array variable with between 1 and 3 dimensions and loads
it as an image. It will not handle complex images. It does not handle
sparse matrices. 

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="max" c:identifier="vips_max" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation finds the maximum value in an image. 

If the image contains several maximum values, only the first one found is
returned.

It operates on all 
bands of the input image: use vips_stats() if you need to find an 
maximum for each band. 

For complex images, this operation finds the maximum modulus.

See also: vips_min(), vips_stats().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output pixel maximum</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="maxpos_avg" c:identifier="im_maxpos_avg">
      <doc xml:whitespace="preserve">Function to find the maximum of an image.  Returns coords and value at
double precision.  In the event of a draw, returns average of all 
drawing coords.

See also: im_maxpos(), im_min(), im_stats().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to scan</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xpos" transfer-ownership="none">
          <doc xml:whitespace="preserve">returned X position</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="ypos" transfer-ownership="none">
          <doc xml:whitespace="preserve">returned Y position</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">returned value</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="maxpos_vec" c:identifier="im_maxpos_vec">
      <doc xml:whitespace="preserve">Find the coordinates and values of the @n @maxima of an image.

For 8 and 16-bit images, it's much faster to find the histogram and then
calculate a threshold from that. See im_mpercent().

See also: im_minpos(), im_min(), im_stats(), im_maxpos_avg().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to scan</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xpos" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return x positions</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="ypos" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return y positions</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="maxima" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return values</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of maxima to search for</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="measure" c:identifier="vips_measure" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Analyse a grid of colour patches, producing an array of patch averages.
The mask has a row for each measured patch and a column for each image
band. The operations issues a warning if any patch has a deviation more 
than 20% of
the mean. Only the central 50% of each patch is averaged. 

If the chart does not fill the whole image, use the optional @left, @top, 
@width, @height arguments to indicate the
position of the chart.

See also: vips_avg(), vips_deviate().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of measurements</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="h" transfer-ownership="none">
          <doc xml:whitespace="preserve">patches across chart</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="v" transfer-ownership="none">
          <doc xml:whitespace="preserve">patches down chart</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="min" c:identifier="vips_min" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation finds the minimum value in an image. 

If the image contains several minimum values, only the first one found is
returned.

It operates on all 
bands of the input image: use vips_stats() if you need to find an 
minimum for each band. 

For complex images, this operation finds the minimum modulus.

See also: vips_max(), vips_stats().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output pixel maximum</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="minpos_vec" c:identifier="im_minpos_vec">
      <doc xml:whitespace="preserve">Find the coordinates and values of the @n @minima of an image.

For 8 and 16-bit images, it's much faster to find the histogram and then
calculate a threshold from that. See im_mpercent().

See also: im_minpos(), im_min(), im_stats(), im_maxpos_avg().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to scan</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xpos" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return x positions</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="ypos" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return y positions</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="minima" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to return values</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of minima to search for</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="more" c:identifier="vips_more" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="more_const"
              c:identifier="vips_more_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="more_const1"
              c:identifier="vips_more_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MORE on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq" c:identifier="vips_moreeq" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq_const"
              c:identifier="vips_moreeq_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="moreeq_const1"
              c:identifier="vips_moreeq_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_MOREEQ on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="msb" c:identifier="im_msb">
      <doc xml:whitespace="preserve">Turn any integer image to 8-bit unsigned char by discarding all but the most
significant byte.
Signed values are converted to unsigned by adding 128.

This operator also works for LABQ coding.

See also: im_msb_band().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msb_band" c:identifier="im_msb_band">
      <doc xml:whitespace="preserve">Turn any integer image to a single-band 8-bit unsigned char by discarding 
all but the most significant byte from the selected band. 
Signed values are converted to unsigned by adding 128.

This operator also works for LABQ coding.

See also: im_msb_band().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">select this band</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="multiply" c:identifier="vips_multiply" introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @left * @right and writes the result to @out. 

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), then the 
following table is used to determine the output type:

&lt;table&gt;
&lt;title&gt;VipsMultiply type promotion&lt;/title&gt;
&lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;input type&lt;/entry&gt;
&lt;entry&gt;output type&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;uchar&lt;/entry&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;char&lt;/entry&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_add(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="notequal" c:identifier="vips_notequal" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQUAL on a pair of images. See
vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="notequal_const"
              c:identifier="vips_notequal_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="notequal_const1"
              c:identifier="vips_notequal_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_RELATIONAL_NOTEQUAL on an image and a constant. See
vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="openexrload"
              c:identifier="vips_openexrload"
              introspectable="0">
      <doc xml:whitespace="preserve">Read a OpenEXR file into a VIPS image. 

The reader can handle scanline and tiled OpenEXR images. It can't handle
OpenEXR colour management, image attributes, many pixel formats, anything
other than RGBA.

This reader uses the rather limited OpenEXR C API. It should really be
redone in C++.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="openslideload"
              c:identifier="vips_openslideload"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Read a virtual slide supported by the OpenSlide library into a VIPS image.
OpenSlide supports images in Aperio, Hamamatsu VMS, Hamamatsu VMU, MIRAX,
and Trestle formats.  

To facilitate zooming, virtual slide formats include multiple scaled-down
versions of the high-resolution image.  These are typically called
"levels", though OpenSlide and im_openslide2vips() call them "layers".
By default, vips_openslideload() reads the highest-resolution layer
(layer 0).  Set @layer to the layer number you want.

In addition to the slide image itself, virtual slide formats sometimes
include additional images, such as a scan of the slide's barcode.
OpenSlide calls these "associated images".  To read an associated image,
set @associated to the image's name.
A slide's associated images are listed in the
"slide-associated-images" metadata item.

The output of this operator is in pre-multipled ARGB format. Use
im_argb2rgba() to decode to png-style RGBA. 

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="orimage" c:identifier="vips_orimage" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="orimage_const"
              c:identifier="vips_orimage_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="orimage_const1"
              c:identifier="vips_orimage_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_OR on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pngload" c:identifier="vips_pngload" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:

Read a PNG file into a VIPS image. It can read all png images, including 8-
and 16-bit images, 1 and 3 channel, with and without an alpha channel.

Any ICC profile is read and attached to the VIPS image.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pngsave" c:identifier="vips_pngsave" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Write a VIPS image to a file as PNG.

@compression means compress with this much effort (0 - 9). Default 6.

Set @interlace to %TRUE to interlace the image with ADAM7 
interlacing. Beware
than an interlaced PNG can be up to 7 times slower to write than a
non-interlaced image.

If the VIPS header 
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

The image is automatically converted to RGB, RGBA, Monochrome or Mono +
alpha before saving. Images with more than one byte per band element are
saved as 16-bit PNG, others are saved as 8-bit PNG.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pngsave_buffer"
              c:identifier="vips_pngsave_buffer"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


As vips_pngsave(), but save to a memory buffer. 

The address of the buffer is returned in @obuf, the length of the buffer in
@olen. You are responsible for freeing the buffer with g_free() when you
are done with it.

See also: vips_pngsave(), vips_image_write_to_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">return output buffer here</doc>
          <type name="gpointer" c:type="void**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">return output length here</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="point" c:identifier="im_point">
      <doc xml:whitespace="preserve">Find the value at (@x, @y) in given band of image.
Non-integral values are calculated using the supplied @interpolate.

See also: im_avg(), #VipsInterpolate</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to read from</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="interpolate" transfer-ownership="none">
          <doc xml:whitespace="preserve">interpolator to sample points with</doc>
          <type name="Interpolate" c:type="VipsInterpolate*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">x position to interpolate</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">y position to interpolate</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">band to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">return interpolated value</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="point_bilinear" c:identifier="im_point_bilinear">
      <doc xml:whitespace="preserve">Find the value at (@x,@y) in given band of image.
Use bilinear interpolation if @x or @y are non-integral. 

See also: im_avg(), im_point().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to read from</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">x position to interpolate</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">y position to interpolate</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:whitespace="preserve">band to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">return interpolated value</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
      </parameters>
    </function>
    <function name="polar" c:identifier="vips_polar" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_COMPLEX_POLAR on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pow" c:identifier="vips_pow" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_POW on a pair of images. See
vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pow_const"
              c:identifier="vips_pow_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_POW on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="pow_const1"
              c:identifier="vips_pow_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_POW on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="ppmload" c:identifier="vips_ppmload" introspectable="0">
      <doc xml:whitespace="preserve">Read a PPM/PBM/PGM/PFM file into a VIPS image. 

It can read 1, 8, 16 and 32 bit images, colour or monochrome,
stored in binary or in ASCII. One bit images become 8 bit VIPS images, 
with 0 and 255 for 0 and 1.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="ppmsave" c:identifier="vips_ppmsave" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Write a VIPS image to a file as PPM. It can write 8, 16 or
32 bit unsigned integer images, float images, colour or monochrome, 
stored as binary or ASCII. 
Integer images of more than 8 bits can only be stored in ASCII.

When writing float (PFM) images the scale factor is set from the 
"pfm-scale" metadata.

Set @ascii to %TRUE to write as human-readable ASCII. Normally data is
written in binary. 

The storage format is indicated by a filename extension. Use one of .pbm,
.pgm, .ppm, .pfm. 

See also: vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="radload" c:identifier="vips_radload" introspectable="0">
      <doc xml:whitespace="preserve">Read a Radiance (HDR) file into a VIPS image. 

Radiance files are read as #VIPS_CODING_RAD. They have one byte for each of
red, green and blue, and one byte of shared exponent. Some operations (like
vips_extract_area()) can work directly with images in this format, but 
mmany (all the arithmetic operations, for example) will not. Unpack 
#VIPS_CODING_RAD images to 3 band float with im_rad2float() if you want to do
arithmetic on them.

This operation ignores some header fields, like VIEW and DATE. It will not 
rotate/flip as the FORMAT string asks.

Sections of this reader from Greg Ward and Radiance with kind permission. 

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="radsave" c:identifier="vips_radsave" introspectable="0">
      <doc xml:whitespace="preserve">Write a VIPS image in Radiance (HDR) format.

Sections of this reader from Greg Ward and Radiance with kind permission. 

See also: vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rawload" c:identifier="vips_rawload" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation mmaps the file, setting @out so that access to that 
image will read from the file.

Use functions like vips_copy() to set the pixel type, byte ordering 
and so on.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">width of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">height of image in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="bands" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of image bands</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rawsave" c:identifier="vips_rawsave" introspectable="0">
      <doc xml:whitespace="preserve">Writes the pixels in @in to the file @filename with no header or other
metadata. 

See also: vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rawsave_fd"
              c:identifier="vips_rawsave_fd"
              introspectable="0">
      <doc xml:whitespace="preserve">Writes the pixels in @in to the @fd with no header or other
metadata.  Handy for implementing other savers.

See also: vips_rawsave().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="real" c:identifier="vips_real" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_COMPLEXGET_REAL on an image. See vips_complexget().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="recomb" c:identifier="vips_recomb" introspectable="0">
      <doc xml:whitespace="preserve">This operation recombines an image's bands. Each pixel in @in is treated as 
an n-element vector, where n is the number of bands in @in, and multipled by
the n x m matrix @m to produce the m-band image @out.

@out is always float, unless @in is double, in which case @out is double
too. No complex images allowed.

It's useful for various sorts of colour space conversions.

See also: vips_bandmean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="m" transfer-ownership="none">
          <doc xml:whitespace="preserve">recombination matrix</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rect" c:identifier="vips_rect" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_COMPLEX_RECT on an image. See vips_complex().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="relational"
              c:identifier="vips_relational"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform various relational operations on pairs of images. 

The output type is always uchar, with 0 for FALSE and 255 for TRUE. 

Less-than and greater-than for complex images compare the modulus. 

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;).

See also: vips_boolean(), vips_relational_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:whitespace="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="relational_const"
              c:identifier="vips_relational_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform various relational operations on an image and an array of
constants.

The output type is always uchar, with 0 for FALSE and 255 for TRUE. 

If the array of constants has just one element, that constant is used for 
all image bands. If the array has more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_boolean(), vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:whitespace="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="relational_const1"
              c:identifier="vips_relational_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform various relational operations on an image and a constant. See
vips_relational_const().

See also: vips_boolean(), vips_relational().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="relational" transfer-ownership="none">
          <doc xml:whitespace="preserve">relational operation to perform</doc>
          <type name="OperationRelational" c:type="VipsOperationRelational"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="remainder"
              c:identifier="vips_remainder"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @left % @right (remainder after integer division) 
and writes the result to @out. The images may have any 
non-complex format. For float formats, vips_remainder() calculates @in1 -
@in2 * floor (@in1 / @in2).

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), and that format is the
result type.

See also: vips_remainder_const(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="remainder_const"
              c:identifier="vips_remainder_const"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @in % @c (remainder after division by an 
array of constants) 
and writes the result to @out. 
The image may have any 
non-complex format. For float formats, vips_remainder_const() calculates 
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for 
all image bands. If the array has more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_remainder(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="remainder_const1"
              c:identifier="vips_remainder_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @in % @c (remainder after division by a 
constant) 
and writes the result to @out. 
The image may have any 
non-complex format. For float formats, vips_remainder_const() calculates 
@in - @c * floor (@in / @c).

If the array of constants has just one element, that constant is used for 
all image bands. If the array has more than one element and they have 
the same number of elements as there are bands in the image, then 
one array element is used for each band. If the arrays have more than one
element and the image only has a single band, the result is a many-band
image where each band corresponds to one array element.

See also: vips_remainder(), vips_divide(), vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="replicate"
              c:identifier="vips_replicate"
              introspectable="0">
      <doc xml:whitespace="preserve">Repeats an image many times.

See also: vips_extract().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="across" transfer-ownership="none">
          <doc xml:whitespace="preserve">repeat input this many times across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="down" transfer-ownership="none">
          <doc xml:whitespace="preserve">repeat input this many times down</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rint" c:identifier="vips_rint" introspectable="0">
      <doc xml:whitespace="preserve">Round to an integral value with #VIPS_OPERATION_ROUND_RINT. See 
vips_round().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rot" c:identifier="vips_rot" introspectable="0">
      <doc xml:whitespace="preserve">Rotate @in by a multiple of 90 degrees.

See also: vips_flip().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:whitespace="preserve">rotation angle</doc>
          <type name="Angle" c:type="VipsAngle"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="round" c:identifier="vips_round" introspectable="0">
      <doc xml:whitespace="preserve">Round to an integral value.

Copy for integer types, round float and 
complex types. 

The format of @out is always the same as @in, so you may wish to cast to an
integer format afterwards.

See also: vips_cast()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="round" transfer-ownership="none">
          <doc xml:whitespace="preserve">#VipsOperationRound rounding operation to perform</doc>
          <type name="OperationRound" c:type="VipsOperationRound"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rshift" c:identifier="vips_rshift" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_RSHIFT on a pair of images. See
vips_boolean().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rshift_const"
              c:identifier="vips_rshift_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_LSHIFT on an image and an array of constants.
See vips_boolean_const().

See also: vips_boolean(), vips_boolean_const1().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="rshift_const1"
              c:identifier="vips_rshift_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_BOOLEAN_RSHIFT on an image and a constant.
See vips_boolean_const1().

See also: vips_boolean(), vips_boolean_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="scale" c:identifier="im_scale">
      <doc xml:whitespace="preserve">Search the image for the maximum and minimum value, then return the image
as unsigned 8-bit, scaled so that the maximum value is 255 and the
minimum is zero.

See also: im_clip2fmt(), im_scaleps().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="scaleps" c:identifier="im_scaleps">
      <doc xml:whitespace="preserve">Scale a power spectrum. Transform with log10(1.0 + pow(x, 0.25)) + .5, 
then scale so max == 255.

See also: im_scale().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sequential"
              c:identifier="vips_sequential"
              introspectable="0">
      <doc xml:whitespace="preserve">This operation behaves rather like vips_copy() between images
@in and @out, except that it checks that pixels are only requested
top-to-bottom. If an out of order request is made, it throws an exception.

This operation is handy with tilecache for loading file formats which are 
strictly top-to-bottom, like PNG. 

See also: vips_image_cache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="shutdown" c:identifier="vips_shutdown">
      <doc xml:whitespace="preserve">Call this to drop caches and close plugins. Run with "--vips-leak" to do 
a leak check too. May be called many times.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="sign" c:identifier="vips_sign" introspectable="0">
      <doc xml:whitespace="preserve">Finds the unit vector in the direction of the pixel value. For non-complex
images, it returns a signed char image with values -1, 0, and 1 for negative,
zero and positive pixels. For complex images, it returns a
complex normalised to length 1.

See also: vips_abs().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="sin" c:identifier="vips_sin" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_SIN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="stats" c:identifier="vips_stats" introspectable="0">
      <doc xml:whitespace="preserve">Find many image statistics in a single pass through the data. @out is a
one-band #VIPS_FORMAT_DOUBLE image of at least 10 columns by n + 1 
(where n is number of bands in image @in) 
rows. Columns are statistics, and are, in order: minimum, maximum, sum, 
sum of squares, mean, standard deviation, x coordinate of minimum, y
coordinate of minimum, x coordinate of maximum, y coordinate of maximum. 
Later versions of vips_stats() may add more columns.

Row 0 has statistics for all 
bands together, row 1 has stats for band 1, and so on.

See also: vips_avg(), vips_min().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to scan</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">image of statistics</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="subsample" c:identifier="im_subsample">
      <doc xml:whitespace="preserve">Subsample an image by an integer fraction. This is fast nearest-neighbour
shrink.

See also: im_shrink(), im_affinei(), im_zoom().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xshrink" transfer-ownership="none">
          <doc xml:whitespace="preserve">horizontal shrink factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="yshrink" transfer-ownership="none">
          <doc xml:whitespace="preserve">vertical shrink factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="subtract" c:identifier="vips_subtract" introspectable="0">
      <doc xml:whitespace="preserve">This operation calculates @in1 - @in2 and writes the result to @out. 

If the images differ in size, the smaller image is enlarged to match the
larger by adding zero pixels along the bottom and right.

If the number of bands differs, one of the images 
must have one band. In this case, an n-band image is formed from the 
one-band image by joining n copies of the one-band image together, and then
the two n-band images are operated upon.

The two input images are cast up to the smallest common type (see table 
Smallest common format in 
&lt;link linkend="VIPS-arithmetic"&gt;arithmetic&lt;/link&gt;), then the 
following table is used to determine the output type:

&lt;table&gt;
&lt;title&gt;VipsSubtract type promotion&lt;/title&gt;
&lt;tgroup cols='2' align='left' colsep='1' rowsep='1'&gt;
&lt;thead&gt;
&lt;row&gt;
&lt;entry&gt;input type&lt;/entry&gt;
&lt;entry&gt;output type&lt;/entry&gt;
&lt;/row&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;row&gt;
&lt;entry&gt;uchar&lt;/entry&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;char&lt;/entry&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;ushort&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;short&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;uint&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;entry&gt;int&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;entry&gt;float&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;entry&gt;double&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;entry&gt;complex&lt;/entry&gt;
&lt;/row&gt;
&lt;row&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;entry&gt;double complex&lt;/entry&gt;
&lt;/row&gt;
&lt;/tbody&gt;
&lt;/tgroup&gt;
&lt;/table&gt;

In other words, the output type is just large enough to hold the whole
range of possible values.

See also: vips_add(), vips_linear().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in1" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in2" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="system" c:identifier="im_system">
      <doc xml:whitespace="preserve">im_system() runs a command on an image, returning the command's output as a
string. The command is executed with popen(), the first '%%s' in the 
command being substituted for a filename.

If the IMAGE is a file on disc, then the filename will be the name of the 
real file. If the image is in memory, or the result of a computation, 
then a new file is created in the temporary area called something like 
"vips_XXXXXX.v", and that filename given to the command. The file is 
deleted when the command finishes.

See im_system_image() for details on how VIPS selects a temporary
directory.

In all cases, @log must be freed with im_free().

See also: im_system_image().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to run command on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="cmd" transfer-ownership="none">
          <doc xml:whitespace="preserve">command to run</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">stdout of command is returned here</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="system_image" c:identifier="im_system_image">
      <doc xml:whitespace="preserve">im_system_image() runs a command, passing an image in and getting an image
back. The command's stdout is returned in @log. 

First, @im is written to a file. The filename is formed by substituting
something like "vips-49857-1" for the first %%s in @in_format, then
prepending "/tmp". If the environment variable TMPDIR is defined, it
can be used to set a different temporary directory. If @in_format is
something like "%%s.png", the file will be written in PNG format.

On Windows, if the environment variable TMPDIR is not defined, VIPS calls 
GetTempPath() to get the user's preferred temporary area. If that fails, it
defaults to C:\temp.

Next an output filename is created in the same way using @out_format. The
command string to run is made by substituting the first %%s in @cmd_format
for the name of the input file and the second %%s for the output filename.

The command is executed with popen() and the output captured in @log. If
the command fails, the temporary files are deleted and im_system_image()
returns NULL. @log is still set.

If the command succeeds, the input file is deleted, the output file opened,
and returned. Closing the output image will automatically delete the file.

In all cases, @log must be freed with im_free().

For example, this call will run the ImageMagick convert program on an
image, using JPEG files to pass images into and out of the convert command.

|[
im_system_image( in, out, 
"%s.jpg", "%s.jpg", "convert %s -swirl 45 %s", 
&amp;log )
]|

See also: im_system().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">an image on success, NULL on error</doc>
        <type name="Image" c:type="VipsImage*"/>
      </return-value>
      <parameters>
        <parameter name="im" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to run command on</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="in_format" transfer-ownership="none">
          <doc xml:whitespace="preserve">write input file like this</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out_format" transfer-ownership="none">
          <doc xml:whitespace="preserve">write output filename like this</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="cmd_format" transfer-ownership="none">
          <doc xml:whitespace="preserve">command to run</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="log" transfer-ownership="none">
          <doc xml:whitespace="preserve">stdout of command is returned here</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="tan" c:identifier="vips_tan" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH_TAN on an image. See vips_math().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="text" c:identifier="im_text">
      <doc xml:whitespace="preserve">Draw the string @text to an image. @out is a one-band 8-bit
unsigned char image, with 0 for no text and 255 for text. Values inbetween
are used for anti-aliasing.

@text is the text to render as a UTF-8 string. It can contain Pango markup,
for example "&amp;lt;i&amp;gt;The&amp;lt;/i&amp;gt;Guardian".

@font is the font to render with, selected by fontconfig. Examples might be
"sans 12" or perhaps "bitstream charter bold 10".

@width is the maximum number of pixels across to draw within. If the
generated text is wider than this, it will wrap to a new line. In this
case, @alignment can be used to set the alignment style for multi-line
text. 0 means left-align, 1 centre, 2 right-align.

@dpi sets the resolution to render at. "sans 12" at 72 dpi draws characters
approximately 12 pixels high.

See also: im_make_xy(), im_black(), im_gaussnoise().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="text" transfer-ownership="none">
          <doc xml:whitespace="preserve">utf-8 text string to render</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="font" transfer-ownership="none">
          <doc xml:whitespace="preserve">font to render with</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">render within this many pixels across</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="alignment" transfer-ownership="none">
          <doc xml:whitespace="preserve">left/centre/right alignment</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dpi" transfer-ownership="none">
          <doc xml:whitespace="preserve">render at this resolution</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="tiffload" c:identifier="vips_tiffload" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


Read a TIFF file into a VIPS image. It is a full baseline TIFF 6 reader, 
with extensions for tiled images, multipage images, LAB colour space, 
pyramidal images and JPEG compression. including CMYK and YCbCr.

@page means load this page from the file. By default the first page (page
0) is read.

Any ICC profile is read and attached to the VIPS image.

See also: vips_image_new_from_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to load</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">decompressed image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="tiffsave" c:identifier="vips_tiffsave" introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:

@compression; use this compression scheme
@predictor; compress with this prediction
@tile; set %TRUE to write a tiled tiff
@tile_width; set tile size
@tile_height; set tile size
@pyramid; set %TRUE to write an image pyramid
@squash; squash 8-bit images down to 1 bit
@resunit; convert resolution to pixels per inch or cm during write
@xres; horizontal resolution in pixels/mm
@yres; vertical resolution in pixels/mm
@bigtiff; write a BigTiff file

Write a VIPS image to a file as TIFF.

Use @compression to set the tiff compression. Currently jpeg, packbits,
fax4, lzw, none and deflate are supported. The default is no compression.
JPEG compression is a good lossy compressor for photographs, packbits is 
good for 1-bit images, and deflate is the best lossless compression TIFF 
can do. LZW has patent problems and is no longer recommended.

Use @Q to set the JPEG compression factor. Default 75.

Use @predictor to set the predictor for lzw and deflate compression. 

Predictor is not set by default. There are three predictor values recognised
at the moment (2007, July): 1 is no prediction, 2 is a horizontal 
differencing and 3 is a floating point predictor. Refer to the libtiff 
specifications for further discussion of various predictors. In short, 
predictor helps to better compress image, especially in case of digital 
photos or scanned images and bit depths &gt; 8. Try it to find whether it 
works for your images.

Use @profile to give the filename of a profile to be embedded in the TIFF.
This does not affect the pixels which are written, just the way 
they are tagged. You can use the special string "none" to mean 
"don't attach a profile".

If no profile is specified and the VIPS header 
contains an ICC profile named VIPS_META_ICC_NAME ("icc-profile-data"), the
profile from the VIPS header will be attached.

Set @tile to TRUE to write a tiled tiff.  By default tiff are written in
strips. Use @tile_width and @tile_height to set the tile size. The defaiult
is 128 by 128.

Set @pyramid to write the image as a set of images, one per page, of
decreasing size. 

Set @squash to make 8-bit uchar images write as 1-bit TIFFs with zero
pixels written as 0 and non-zero as 1.

Use @resunit to override the default resolution unit.  
The default 
resolution unit is taken from the header field "resolution-unit"
(#VIPS_META_RESOLUTION_UNIT in C). If this field is not set, then 
VIPS defaults to cm.

Use @xres and @yres to override the default horizontal and vertical
resolutions. By default these values are taken from the VIPS image header. 
libvips resolution is always in pixels per millimetre.

Set @bigtiff to attempt to write a bigtiff. 
Bigtiff is a variant of the TIFF
format that allows more than 4GB in a file.

See also: vips_tiffload(), vips_image_write_file().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">image to save</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">file to write to</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="tilecache"
              c:identifier="vips_tilecache"
              introspectable="0">
      <doc xml:whitespace="preserve">Optional arguments:


This operation behaves rather like vips_copy() between images
@in and @out, except that it keeps a cache of computed pixels. 
This cache is made of up to @max_tiles tiles (a value of -1 
means any number of tiles), and each tile is of size @tile_width
by @tile_height pixels. 

Each cache tile is made with a single call to 
vips_image_prepare(). 

When the cache fills, a tile is chosen for reuse. If @strategy is
#VIPS_CACHE_RANDOM, then the least-recently-used tile is reused. If 
@strategy is #VIPS_CACHE_SEQUENTIAL, the top-most tile is reused.

By default, @tile_width and @tile_height are 128 pixels, and the operation
will cache up to 1,000 tiles. @strategy defaults to #VIPS_CACHE_RANDOM.

This is a lower-level operation than vips_image_cache() since it does no 
subdivision and it single-threads its callee. It is suitable for caching 
the output of operations like exr2vips() on tiled images.

See also: vips_image_cache().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="type_depth" c:identifier="vips_type_depth">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find" c:identifier="vips_type_find">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="basename" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="nickname" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map" c:identifier="vips_type_map" introspectable="0">
      <doc xml:whitespace="preserve">Map over a type's children. Stop when @fn returns non-%NULL
and return that value. 

non-%NULL value from @fn.</doc>
      <return-value>
        <doc xml:whitespace="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:whitespace="preserve">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:whitespace="preserve">call this function for every type</doc>
          <type name="TypeMap2Fn" c:type="VipsTypeMap2Fn"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_map_all"
              c:identifier="vips_type_map_all"
              introspectable="0">
      <doc xml:whitespace="preserve">Map over a type's children, direct and indirect. Stop when @fn returns 
non-%NULL and return that value. 

non-%NULL value from @fn.</doc>
      <return-value>
        <doc xml:whitespace="preserve">%NULL if @fn returns %NULL for all arguments, otherwise the first</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="base" transfer-ownership="none">
          <doc xml:whitespace="preserve">base type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="fn" transfer-ownership="none">
          <doc xml:whitespace="preserve">call this function for every type</doc>
          <type name="TypeMapFn" c:type="VipsTypeMapFn"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">client data</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_area" c:identifier="vips_value_get_area">
      <doc xml:whitespace="preserve">Get the pointer from an area. Don't touch count (area is static).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The pointer held by @value.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">get from this value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optionally return length here</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array" c:identifier="vips_value_get_array">
      <doc xml:whitespace="preserve">Return the pointer to the array held by @value.
Optionally return the other properties of the array in @n, @type,
@sizeof_type.

See also: vips_value_set_array().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The array address.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return the type of each element here, optionally</doc>
          <type name="GType" c:type="GType*"/>
        </parameter>
        <parameter name="sizeof_type" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return the sizeof each element here, optionally</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_double"
              c:identifier="vips_value_get_array_double">
      <doc xml:whitespace="preserve">Return the start of the array of doubles held by @value.
optionally return the number of elements in @n.

See also: vips_array_double_set().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The array address.</doc>
        <type name="gdouble" c:type="double*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_array_object"
              c:identifier="vips_value_get_array_object"
              introspectable="0">
      <doc xml:whitespace="preserve">Return the start of the array of %GObject held by @value.
optionally return the number of elements in @n.

See also: vips_array_object_set().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The array address.</doc>
        <type name="GObject.Object" c:type="GObject**"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return the number of elements here, optionally</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_blob" c:identifier="vips_value_get_blob">
      <doc xml:whitespace="preserve">Returns the data pointer from a blob. Optionally returns the length too.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

See also: vips_value_set_blob()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The pointer held by @value.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">optionally return length of memory area</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_ref_string"
              c:identifier="vips_value_get_ref_string">
      <doc xml:whitespace="preserve">Get the C string held internally by the GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The C string held by @value.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">return length here, optionally</doc>
          <type name="gulong" c:type="size_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_save_string"
              c:identifier="vips_value_get_save_string">
      <doc xml:whitespace="preserve">Get the C string held internally by the GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The C string held by @value.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_null" c:identifier="vips_value_is_null">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="psoec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_area" c:identifier="vips_value_set_area">
      <doc xml:whitespace="preserve">Set value to be a ref-counted area of memory with a free function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">set this value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">data will be freed with this function</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">set @value to track this pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array" c:identifier="vips_value_set_array">
      <doc xml:whitespace="preserve">Set @value to be an array of things. 

This allocates memory but does not 
initialise the contents: get the pointer and write instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of each element</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="sizeof_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sizeof each element</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_double"
              c:identifier="vips_value_set_array_double">
      <doc xml:whitespace="preserve">Set @value to hold a copy of @array. Pass in the array length in @n. 

See also: vips_array_double_get().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">%GValue to get from</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of doubles</doc>
          <array length="2" zero-terminated="0" c:type="double*">
            <type name="gdouble" c:type="double"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of elements</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_array_object"
              c:identifier="vips_value_set_array_object">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_blob" c:identifier="vips_value_set_blob">
      <doc xml:whitespace="preserve">Sets @value to hold a @data. When @value is freed, @data will be
freed with @free_fn. @value also holds a note of the length of the memory
area.

blobs are things like ICC profiles or EXIF data. They are relocatable, and
are saved to VIPS files for you coded as base64 inside the XML. They are
copied by copying reference-counted pointers.

See also: vips_value_get_blob()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="free_fn"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:whitespace="preserve">free function for @data</doc>
          <type name="CallbackFn" c:type="VipsCallbackFn"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to area of memory</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">length of memory area</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_ref_string"
              c:identifier="vips_value_set_ref_string">
      <doc xml:whitespace="preserve">Copies the C string @str into @value. 

vips_ref_string are immutable C strings that are copied between images by
copying reference-counted pointers, making the much more efficient than
regular GValue strings.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 otherwise.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">C string to copy into the GValue</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_string"
              c:identifier="vips_value_set_save_string">
      <doc xml:whitespace="preserve">Copies the C string into @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">C string to copy into the GValue</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_save_stringf"
              c:identifier="vips_value_set_save_stringf"
              introspectable="0">
      <doc xml:whitespace="preserve">Generates a string and copies it into @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="vdiag" c:identifier="vips_vdiag" introspectable="0">
      <doc xml:whitespace="preserve">Sends a formatted diagnostic message to stderr. If you define the
environment variable IM_DIAGNOSTICS, these message are surpressed.

Diagnostic messages are used to report details about the operation of
functions.

See also: vips_diag(), vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the diagnostic message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:whitespace="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="verror" c:identifier="vips_verror" introspectable="0">
      <doc xml:whitespace="preserve">Append a message to the error buffer.

See also: vips_error().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:whitespace="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="verror_system"
              c:identifier="vips_verror_system"
              introspectable="0">
      <doc xml:whitespace="preserve">Format the string in the style of printf() and append to the error buffer.
Then create and append a localised message based on the system error code,
usually the value of errno.

See also: vips_error_system().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="err" transfer-ownership="none">
          <doc xml:whitespace="preserve">the system error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the error</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:whitespace="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="vips_version">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="flag" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="version_string" c:identifier="vips_version_string">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="vwarn" c:identifier="vips_vwarn" introspectable="0">
      <doc xml:whitespace="preserve">Sends a formatted warning message to stderr. If you define the
environment variable IM_WARNING, these message are surpressed.

Warning messages are used to report things like overflow counts.

See also: vips_diag(), vips_warn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the warning message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ap" transfer-ownership="none">
          <doc xml:whitespace="preserve">arguments to the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="warn" c:identifier="vips_warn" introspectable="0">
      <doc xml:whitespace="preserve">Sends a formatted warning message to stderr. If you define the
environment variable IM_WARNING, these message are surpressed.

Warning messages are used to report things like overflow counts.

See also: vips_diag(), vips_vwarn().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the warning message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="fmt" transfer-ownership="none">
          <doc xml:whitespace="preserve">printf()-style format string for the message</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="wop" c:identifier="vips_wop" introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_WOP on a pair of images. See
vips_math2().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">right-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="wop_const"
              c:identifier="vips_wop_const"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_WOP on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">array of constants</doc>
          <type name="gdouble" c:type="double*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of constants in @c</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="wop_const1"
              c:identifier="vips_wop_const1"
              introspectable="0">
      <doc xml:whitespace="preserve">Perform #VIPS_OPERATION_MATH2_WOP on an image and a constant. See
vips_math2_const().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">left-hand input #VipsImage</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output #VipsImage</doc>
          <type name="Image" c:type="VipsImage**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="wrap" c:identifier="im_wrap">
      <doc xml:whitespace="preserve">Slice an image up and move the segments about so that the pixel that was
at 0, 0 is now at @x, @y.

See also: im_embed(), im_replicate(), im_rotquad().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">horizontal displacement</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">vertical displacement</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="zoom" c:identifier="im_zoom">
      <doc xml:whitespace="preserve">Zoom an image by repeating pixels. This is fast nearest-neighbour
zoom.

See also: im_affinei(), im_subsample().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 on success, -1 on error.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:whitespace="preserve">input image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="out" transfer-ownership="none">
          <doc xml:whitespace="preserve">output image</doc>
          <type name="Image" c:type="VipsImage*"/>
        </parameter>
        <parameter name="xfac" transfer-ownership="none">
          <doc xml:whitespace="preserve">horizontal scale factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="yfac" transfer-ownership="none">
          <doc xml:whitespace="preserve">vertical scale factor</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
