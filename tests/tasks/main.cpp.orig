#include "core/core.h"
#include "core/taskqueue.h"
#include "memory/atomics.h"
#include "platform/logging.h"
#include "platform/threading.h"

enum {
VD_INVALID_VALUE
};

class TestTaskQueue : public vd::core::TaskQueue 
{
public:

	void SetParams(vd::i32 thnum, double interval) 
	{
	  thnum_ = thnum;
	  interval_ = interval;
	  finished_ = 0;
	}

	virtual void 
	OnAddTask(vd::core::TaskQueue::Task* task)
	{
		finished_ += 1;
		if (interval_ > 0) {
			vd::platform::Thread::Sleep(interval_ * thnum_);
		} else if (interval_ < 0) {
			vd::platform::Thread::Yield();
		}
		delete task;
	}

	vd::i64 DoneCount() 
	{
		return finished_.value();
	}

private:
	vd::i32 thnum_;
	double interval_;
	vd::memory::AtomicCounter finished_;
};

int main()
{
	vd::u64 randseed = 987654321;
	vd::i64 rnum = 1;
	vd::i32 thnum = 1;
	double interval = 1.0f;
	vdInfo("Task Queue: seed=%u  rnum=%lld  thnum=%d  interval=%.3f\n\n",
		  randseed, (long long)rnum, thnum, interval);

	double start = vd::platform::GetTimeInSeconds();
  TestTaskQueue queue;
  queue.SetParams(thnum, interval);
  queue.Start(thnum);

  for (int64_t i = 1; i <= rnum; i++) 
  {
    vd::core::TaskQueue::Task* task = new vd::core::TaskQueue::Task;
    queue.AddTask(task);
    if (interval > 0) 
    {
    	vd::platform::Thread::Sleep(interval);
    } 
    else if (interval < 0) 
    {
    	vd::platform::Thread::Yield();
    }
    if (rnum > 250 && i % (rnum / 250) == 0) {
      vdInfo(".");
      if (i == rnum || i % (rnum / 10) == 0) vdInfo(" (%08lld)\n", (long long)i);
    }
  }
  vdInfo("count: %lld\n", queue.ActiveCount());
  vdInfo("done: %lld\n", queue.DoneCount());
  queue.Finish();

	bool err = false;
  if (queue.ActiveCount() != 0) 
  {
    vdError(VD_INVALID_VALUE, "TaskQueue::ActiveCount");
    err = true;
  }
  
  if (queue.DoneCount() != rnum) 
  {
    vdError(VD_INVALID_VALUE, "TaskQueue::DoneCount");
    err = true;
  }
//  double etime = kc::time();
	double end = vd::platform::GetTimeInSeconds();
	vdInfo("Time: %.3f sec\n", end - start);
	return 0;
}
